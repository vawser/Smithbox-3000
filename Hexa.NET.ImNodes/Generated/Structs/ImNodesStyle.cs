// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;
using Hexa.NET.ImGui;

namespace Hexa.NET.ImNodes
{
	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImNodesStyle
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public float GridSpacing;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float NodeCornerRounding;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 NodePadding;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float NodeBorderThickness;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float LinkThickness;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float LinkLineSegmentsPerLength;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float LinkHoverDistance;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float PinCircleRadius;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float PinQuadSideLength;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float PinTriangleSideLength;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float PinLineThickness;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float PinHoverRadius;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float PinOffset;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 MiniMapPadding;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 MiniMapOffset;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImNodesStyleFlags Flags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint Colors_0;
		public uint Colors_1;
		public uint Colors_2;
		public uint Colors_3;
		public uint Colors_4;
		public uint Colors_5;
		public uint Colors_6;
		public uint Colors_7;
		public uint Colors_8;
		public uint Colors_9;
		public uint Colors_10;
		public uint Colors_11;
		public uint Colors_12;
		public uint Colors_13;
		public uint Colors_14;
		public uint Colors_15;
		public uint Colors_16;
		public uint Colors_17;
		public uint Colors_18;
		public uint Colors_19;
		public uint Colors_20;
		public uint Colors_21;
		public uint Colors_22;
		public uint Colors_23;
		public uint Colors_24;
		public uint Colors_25;
		public uint Colors_26;
		public uint Colors_27;
		public uint Colors_28;


		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImNodesStyle(float gridSpacing = default, float nodeCornerRounding = default, Vector2 nodePadding = default, float nodeBorderThickness = default, float linkThickness = default, float linkLineSegmentsPerLength = default, float linkHoverDistance = default, float pinCircleRadius = default, float pinQuadSideLength = default, float pinTriangleSideLength = default, float pinLineThickness = default, float pinHoverRadius = default, float pinOffset = default, Vector2 miniMapPadding = default, Vector2 miniMapOffset = default, ImNodesStyleFlags flags = default, uint* colors = default)
		{
			GridSpacing = gridSpacing;
			NodeCornerRounding = nodeCornerRounding;
			NodePadding = nodePadding;
			NodeBorderThickness = nodeBorderThickness;
			LinkThickness = linkThickness;
			LinkLineSegmentsPerLength = linkLineSegmentsPerLength;
			LinkHoverDistance = linkHoverDistance;
			PinCircleRadius = pinCircleRadius;
			PinQuadSideLength = pinQuadSideLength;
			PinTriangleSideLength = pinTriangleSideLength;
			PinLineThickness = pinLineThickness;
			PinHoverRadius = pinHoverRadius;
			PinOffset = pinOffset;
			MiniMapPadding = miniMapPadding;
			MiniMapOffset = miniMapOffset;
			Flags = flags;
			if (colors != default(uint*))
			{
				Colors_0 = colors[0];
				Colors_1 = colors[1];
				Colors_2 = colors[2];
				Colors_3 = colors[3];
				Colors_4 = colors[4];
				Colors_5 = colors[5];
				Colors_6 = colors[6];
				Colors_7 = colors[7];
				Colors_8 = colors[8];
				Colors_9 = colors[9];
				Colors_10 = colors[10];
				Colors_11 = colors[11];
				Colors_12 = colors[12];
				Colors_13 = colors[13];
				Colors_14 = colors[14];
				Colors_15 = colors[15];
				Colors_16 = colors[16];
				Colors_17 = colors[17];
				Colors_18 = colors[18];
				Colors_19 = colors[19];
				Colors_20 = colors[20];
				Colors_21 = colors[21];
				Colors_22 = colors[22];
				Colors_23 = colors[23];
				Colors_24 = colors[24];
				Colors_25 = colors[25];
				Colors_26 = colors[26];
				Colors_27 = colors[27];
				Colors_28 = colors[28];
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImNodesStyle(float gridSpacing = default, float nodeCornerRounding = default, Vector2 nodePadding = default, float nodeBorderThickness = default, float linkThickness = default, float linkLineSegmentsPerLength = default, float linkHoverDistance = default, float pinCircleRadius = default, float pinQuadSideLength = default, float pinTriangleSideLength = default, float pinLineThickness = default, float pinHoverRadius = default, float pinOffset = default, Vector2 miniMapPadding = default, Vector2 miniMapOffset = default, ImNodesStyleFlags flags = default, Span<uint> colors = default)
		{
			GridSpacing = gridSpacing;
			NodeCornerRounding = nodeCornerRounding;
			NodePadding = nodePadding;
			NodeBorderThickness = nodeBorderThickness;
			LinkThickness = linkThickness;
			LinkLineSegmentsPerLength = linkLineSegmentsPerLength;
			LinkHoverDistance = linkHoverDistance;
			PinCircleRadius = pinCircleRadius;
			PinQuadSideLength = pinQuadSideLength;
			PinTriangleSideLength = pinTriangleSideLength;
			PinLineThickness = pinLineThickness;
			PinHoverRadius = pinHoverRadius;
			PinOffset = pinOffset;
			MiniMapPadding = miniMapPadding;
			MiniMapOffset = miniMapOffset;
			Flags = flags;
			if (colors != default(Span<uint>))
			{
				Colors_0 = colors[0];
				Colors_1 = colors[1];
				Colors_2 = colors[2];
				Colors_3 = colors[3];
				Colors_4 = colors[4];
				Colors_5 = colors[5];
				Colors_6 = colors[6];
				Colors_7 = colors[7];
				Colors_8 = colors[8];
				Colors_9 = colors[9];
				Colors_10 = colors[10];
				Colors_11 = colors[11];
				Colors_12 = colors[12];
				Colors_13 = colors[13];
				Colors_14 = colors[14];
				Colors_15 = colors[15];
				Colors_16 = colors[16];
				Colors_17 = colors[17];
				Colors_18 = colors[18];
				Colors_19 = colors[19];
				Colors_20 = colors[20];
				Colors_21 = colors[21];
				Colors_22 = colors[22];
				Colors_23 = colors[23];
				Colors_24 = colors[24];
				Colors_25 = colors[25];
				Colors_26 = colors[26];
				Colors_27 = colors[27];
				Colors_28 = colors[28];
			}
		}


		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void Destroy()
		{
			fixed (ImNodesStyle* @this = &this)
			{
				ImNodes.DestroyNative(@this);
			}
		}

	}

	/// <summary>
	/// To be documented.
	/// </summary>
	#if NET5_0_OR_GREATER
	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	#endif
	public unsafe struct ImNodesStylePtr : IEquatable<ImNodesStylePtr>
	{
		public ImNodesStylePtr(ImNodesStyle* handle) { Handle = handle; }

		public ImNodesStyle* Handle;

		public bool IsNull => Handle == null;

		public static ImNodesStylePtr Null => new ImNodesStylePtr(null);

		public ImNodesStyle this[int index] { get => Handle[index]; set => Handle[index] = value; }

		public static implicit operator ImNodesStylePtr(ImNodesStyle* handle) => new ImNodesStylePtr(handle);

		public static implicit operator ImNodesStyle*(ImNodesStylePtr handle) => handle.Handle;

		public static bool operator ==(ImNodesStylePtr left, ImNodesStylePtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImNodesStylePtr left, ImNodesStylePtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImNodesStylePtr left, ImNodesStyle* right) => left.Handle == right;

		public static bool operator !=(ImNodesStylePtr left, ImNodesStyle* right) => left.Handle != right;

		public bool Equals(ImNodesStylePtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImNodesStylePtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		#if NET5_0_OR_GREATER
		private string DebuggerDisplay => string.Format("ImNodesStylePtr [0x{0}]", ((nuint)Handle).ToString("X"));
		#endif
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref float GridSpacing => ref Unsafe.AsRef<float>(&Handle->GridSpacing);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref float NodeCornerRounding => ref Unsafe.AsRef<float>(&Handle->NodeCornerRounding);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref Vector2 NodePadding => ref Unsafe.AsRef<Vector2>(&Handle->NodePadding);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref float NodeBorderThickness => ref Unsafe.AsRef<float>(&Handle->NodeBorderThickness);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref float LinkThickness => ref Unsafe.AsRef<float>(&Handle->LinkThickness);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref float LinkLineSegmentsPerLength => ref Unsafe.AsRef<float>(&Handle->LinkLineSegmentsPerLength);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref float LinkHoverDistance => ref Unsafe.AsRef<float>(&Handle->LinkHoverDistance);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref float PinCircleRadius => ref Unsafe.AsRef<float>(&Handle->PinCircleRadius);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref float PinQuadSideLength => ref Unsafe.AsRef<float>(&Handle->PinQuadSideLength);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref float PinTriangleSideLength => ref Unsafe.AsRef<float>(&Handle->PinTriangleSideLength);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref float PinLineThickness => ref Unsafe.AsRef<float>(&Handle->PinLineThickness);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref float PinHoverRadius => ref Unsafe.AsRef<float>(&Handle->PinHoverRadius);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref float PinOffset => ref Unsafe.AsRef<float>(&Handle->PinOffset);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref Vector2 MiniMapPadding => ref Unsafe.AsRef<Vector2>(&Handle->MiniMapPadding);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref Vector2 MiniMapOffset => ref Unsafe.AsRef<Vector2>(&Handle->MiniMapOffset);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref ImNodesStyleFlags Flags => ref Unsafe.AsRef<ImNodesStyleFlags>(&Handle->Flags);
		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe Span<uint> Colors
		
		{
			get
			{
				return new Span<uint>(&Handle->Colors_0, 29);
			}
		}
		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void Destroy()
		{
			ImNodes.DestroyNative(Handle);
		}

	}

}
