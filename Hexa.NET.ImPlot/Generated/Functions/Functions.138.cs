// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;
using Hexa.NET.ImGui;

namespace Hexa.NET.ImPlot
{
	public unsafe partial class ImPlot
	{

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotPlotPtr GetPlot(ref byte title)
		{
			fixed (byte* ptitle = &title)
			{
				ImPlotPlotPtr ret = GetPlotNative((byte*)ptitle);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotPlotPtr GetPlot(ReadOnlySpan<byte> title)
		{
			fixed (byte* ptitle = title)
			{
				ImPlotPlotPtr ret = GetPlotNative((byte*)ptitle);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotPlotPtr GetPlot(string title)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (title != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(title);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(title, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImPlotPlotPtr ret = GetPlotNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImPlotPlot* GetCurrentPlotNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotPlot*>)funcTable[605])();
			#else
			return (ImPlotPlot*)((delegate* unmanaged[Cdecl]<nint>)funcTable[605])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotPlotPtr GetCurrentPlot()
		{
			ImPlotPlotPtr ret = GetCurrentPlotNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BustPlotCacheNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[606])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[606])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void BustPlotCache()
		{
			BustPlotCacheNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShowPlotContextMenuNative(ImPlotPlot* plot)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotPlot*, void>)funcTable[607])(plot);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[607])((nint)plot);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowPlotContextMenu(ImPlotPlotPtr plot)
		{
			ShowPlotContextMenuNative(plot);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowPlotContextMenu(ref ImPlotPlot plot)
		{
			fixed (ImPlotPlot* pplot = &plot)
			{
				ShowPlotContextMenuNative((ImPlotPlot*)pplot);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetupLockNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[608])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[608])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetupLock()
		{
			SetupLockNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SubplotNextCellNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[609])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[609])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SubplotNextCell()
		{
			SubplotNextCellNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShowSubplotsContextMenuNative(ImPlotSubplot* subplot)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotSubplot*, void>)funcTable[610])(subplot);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[610])((nint)subplot);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowSubplotsContextMenu(ImPlotSubplotPtr subplot)
		{
			ShowSubplotsContextMenuNative(subplot);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowSubplotsContextMenu(ref ImPlotSubplot subplot)
		{
			fixed (ImPlotSubplot* psubplot = &subplot)
			{
				ShowSubplotsContextMenuNative((ImPlotSubplot*)psubplot);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte BeginItemNative(byte* labelId, ImPlotItemFlags flags, ImPlotCol recolorFrom)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, ImPlotItemFlags, ImPlotCol, byte>)funcTable[611])(labelId, flags, recolorFrom);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, ImPlotItemFlags, ImPlotCol, byte>)funcTable[611])((nint)labelId, flags, recolorFrom);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginItem(byte* labelId, ImPlotItemFlags flags, ImPlotCol recolorFrom)
		{
			byte ret = BeginItemNative(labelId, flags, recolorFrom);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginItem(byte* labelId, ImPlotItemFlags flags)
		{
			byte ret = BeginItemNative(labelId, flags, (ImPlotCol)(-1));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginItem(byte* labelId)
		{
			byte ret = BeginItemNative(labelId, (ImPlotItemFlags)(0), (ImPlotCol)(-1));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginItem(byte* labelId, ImPlotCol recolorFrom)
		{
			byte ret = BeginItemNative(labelId, (ImPlotItemFlags)(0), recolorFrom);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginItem(ref byte labelId, ImPlotItemFlags flags, ImPlotCol recolorFrom)
		{
			fixed (byte* plabelId = &labelId)
			{
				byte ret = BeginItemNative((byte*)plabelId, flags, recolorFrom);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginItem(ref byte labelId, ImPlotItemFlags flags)
		{
			fixed (byte* plabelId = &labelId)
			{
				byte ret = BeginItemNative((byte*)plabelId, flags, (ImPlotCol)(-1));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginItem(ref byte labelId)
		{
			fixed (byte* plabelId = &labelId)
			{
				byte ret = BeginItemNative((byte*)plabelId, (ImPlotItemFlags)(0), (ImPlotCol)(-1));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginItem(ref byte labelId, ImPlotCol recolorFrom)
		{
			fixed (byte* plabelId = &labelId)
			{
				byte ret = BeginItemNative((byte*)plabelId, (ImPlotItemFlags)(0), recolorFrom);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginItem(ReadOnlySpan<byte> labelId, ImPlotItemFlags flags, ImPlotCol recolorFrom)
		{
			fixed (byte* plabelId = labelId)
			{
				byte ret = BeginItemNative((byte*)plabelId, flags, recolorFrom);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginItem(ReadOnlySpan<byte> labelId, ImPlotItemFlags flags)
		{
			fixed (byte* plabelId = labelId)
			{
				byte ret = BeginItemNative((byte*)plabelId, flags, (ImPlotCol)(-1));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginItem(ReadOnlySpan<byte> labelId)
		{
			fixed (byte* plabelId = labelId)
			{
				byte ret = BeginItemNative((byte*)plabelId, (ImPlotItemFlags)(0), (ImPlotCol)(-1));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginItem(ReadOnlySpan<byte> labelId, ImPlotCol recolorFrom)
		{
			fixed (byte* plabelId = labelId)
			{
				byte ret = BeginItemNative((byte*)plabelId, (ImPlotItemFlags)(0), recolorFrom);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginItem(string labelId, ImPlotItemFlags flags, ImPlotCol recolorFrom)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (labelId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(labelId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(labelId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginItemNative(pStr0, flags, recolorFrom);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginItem(string labelId, ImPlotItemFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (labelId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(labelId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(labelId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginItemNative(pStr0, flags, (ImPlotCol)(-1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginItem(string labelId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (labelId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(labelId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(labelId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginItemNative(pStr0, (ImPlotItemFlags)(0), (ImPlotCol)(-1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginItem(string labelId, ImPlotCol recolorFrom)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (labelId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(labelId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(labelId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginItemNative(pStr0, (ImPlotItemFlags)(0), recolorFrom);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EndItemNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[612])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[612])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void EndItem()
		{
			EndItemNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImPlotItem* RegisterOrGetItemNative(byte* labelId, ImPlotItemFlags flags, bool* justCreated)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, ImPlotItemFlags, bool*, ImPlotItem*>)funcTable[613])(labelId, flags, justCreated);
			#else
			return (ImPlotItem*)((delegate* unmanaged[Cdecl]<nint, ImPlotItemFlags, nint, nint>)funcTable[613])((nint)labelId, flags, (nint)justCreated);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotItemPtr RegisterOrGetItem(byte* labelId, ImPlotItemFlags flags, bool* justCreated)
		{
			ImPlotItemPtr ret = RegisterOrGetItemNative(labelId, flags, justCreated);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotItemPtr RegisterOrGetItem(byte* labelId, ImPlotItemFlags flags)
		{
			ImPlotItemPtr ret = RegisterOrGetItemNative(labelId, flags, (bool*)(default));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotItemPtr RegisterOrGetItem(ref byte labelId, ImPlotItemFlags flags, bool* justCreated)
		{
			fixed (byte* plabelId = &labelId)
			{
				ImPlotItemPtr ret = RegisterOrGetItemNative((byte*)plabelId, flags, justCreated);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotItemPtr RegisterOrGetItem(ref byte labelId, ImPlotItemFlags flags)
		{
			fixed (byte* plabelId = &labelId)
			{
				ImPlotItemPtr ret = RegisterOrGetItemNative((byte*)plabelId, flags, (bool*)(default));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotItemPtr RegisterOrGetItem(ReadOnlySpan<byte> labelId, ImPlotItemFlags flags, bool* justCreated)
		{
			fixed (byte* plabelId = labelId)
			{
				ImPlotItemPtr ret = RegisterOrGetItemNative((byte*)plabelId, flags, justCreated);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotItemPtr RegisterOrGetItem(ReadOnlySpan<byte> labelId, ImPlotItemFlags flags)
		{
			fixed (byte* plabelId = labelId)
			{
				ImPlotItemPtr ret = RegisterOrGetItemNative((byte*)plabelId, flags, (bool*)(default));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotItemPtr RegisterOrGetItem(string labelId, ImPlotItemFlags flags, bool* justCreated)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (labelId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(labelId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(labelId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImPlotItemPtr ret = RegisterOrGetItemNative(pStr0, flags, justCreated);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotItemPtr RegisterOrGetItem(string labelId, ImPlotItemFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (labelId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(labelId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(labelId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImPlotItemPtr ret = RegisterOrGetItemNative(pStr0, flags, (bool*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotItemPtr RegisterOrGetItem(byte* labelId, ImPlotItemFlags flags, ref bool justCreated)
		{
			fixed (bool* pjustCreated = &justCreated)
			{
				ImPlotItemPtr ret = RegisterOrGetItemNative(labelId, flags, (bool*)pjustCreated);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotItemPtr RegisterOrGetItem(ref byte labelId, ImPlotItemFlags flags, ref bool justCreated)
		{
			fixed (byte* plabelId = &labelId)
			{
				fixed (bool* pjustCreated = &justCreated)
				{
					ImPlotItemPtr ret = RegisterOrGetItemNative((byte*)plabelId, flags, (bool*)pjustCreated);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotItemPtr RegisterOrGetItem(ReadOnlySpan<byte> labelId, ImPlotItemFlags flags, ref bool justCreated)
		{
			fixed (byte* plabelId = labelId)
			{
				fixed (bool* pjustCreated = &justCreated)
				{
					ImPlotItemPtr ret = RegisterOrGetItemNative((byte*)plabelId, flags, (bool*)pjustCreated);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotItemPtr RegisterOrGetItem(string labelId, ImPlotItemFlags flags, ref bool justCreated)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (labelId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(labelId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(labelId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* pjustCreated = &justCreated)
			{
				ImPlotItemPtr ret = RegisterOrGetItemNative(pStr0, flags, (bool*)pjustCreated);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImPlotItem* GetItemNative(byte* labelId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, ImPlotItem*>)funcTable[614])(labelId);
			#else
			return (ImPlotItem*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[614])((nint)labelId);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotItemPtr GetItem(byte* labelId)
		{
			ImPlotItemPtr ret = GetItemNative(labelId);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotItemPtr GetItem(ref byte labelId)
		{
			fixed (byte* plabelId = &labelId)
			{
				ImPlotItemPtr ret = GetItemNative((byte*)plabelId);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotItemPtr GetItem(ReadOnlySpan<byte> labelId)
		{
			fixed (byte* plabelId = labelId)
			{
				ImPlotItemPtr ret = GetItemNative((byte*)plabelId);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotItemPtr GetItem(string labelId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (labelId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(labelId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(labelId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImPlotItemPtr ret = GetItemNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImPlotItem* GetCurrentItemNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotItem*>)funcTable[615])();
			#else
			return (ImPlotItem*)((delegate* unmanaged[Cdecl]<nint>)funcTable[615])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotItemPtr GetCurrentItem()
		{
			ImPlotItemPtr ret = GetCurrentItemNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BustItemCacheNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[616])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[616])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void BustItemCache()
		{
			BustItemCacheNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte AnyAxesInputLockedNative(ImPlotAxis* axes, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotAxis*, int, byte>)funcTable[617])(axes, count);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, byte>)funcTable[617])((nint)axes, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool AnyAxesInputLocked(ImPlotAxisPtr axes, int count)
		{
			byte ret = AnyAxesInputLockedNative(axes, count);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool AnyAxesInputLocked(ref ImPlotAxis axes, int count)
		{
			fixed (ImPlotAxis* paxes = &axes)
			{
				byte ret = AnyAxesInputLockedNative((ImPlotAxis*)paxes, count);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte AllAxesInputLockedNative(ImPlotAxis* axes, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotAxis*, int, byte>)funcTable[618])(axes, count);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, byte>)funcTable[618])((nint)axes, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool AllAxesInputLocked(ImPlotAxisPtr axes, int count)
		{
			byte ret = AllAxesInputLockedNative(axes, count);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool AllAxesInputLocked(ref ImPlotAxis axes, int count)
		{
			fixed (ImPlotAxis* paxes = &axes)
			{
				byte ret = AllAxesInputLockedNative((ImPlotAxis*)paxes, count);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte AnyAxesHeldNative(ImPlotAxis* axes, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotAxis*, int, byte>)funcTable[619])(axes, count);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, byte>)funcTable[619])((nint)axes, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool AnyAxesHeld(ImPlotAxisPtr axes, int count)
		{
			byte ret = AnyAxesHeldNative(axes, count);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool AnyAxesHeld(ref ImPlotAxis axes, int count)
		{
			fixed (ImPlotAxis* paxes = &axes)
			{
				byte ret = AnyAxesHeldNative((ImPlotAxis*)paxes, count);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte AnyAxesHoveredNative(ImPlotAxis* axes, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotAxis*, int, byte>)funcTable[620])(axes, count);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, byte>)funcTable[620])((nint)axes, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool AnyAxesHovered(ImPlotAxisPtr axes, int count)
		{
			byte ret = AnyAxesHoveredNative(axes, count);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool AnyAxesHovered(ref ImPlotAxis axes, int count)
		{
			fixed (ImPlotAxis* paxes = &axes)
			{
				byte ret = AnyAxesHoveredNative((ImPlotAxis*)paxes, count);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte FitThisFrameNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[621])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[621])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool FitThisFrame()
		{
			byte ret = FitThisFrameNative();
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FitPointXNative(double x)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double, void>)funcTable[622])(x);
			#else
			((delegate* unmanaged[Cdecl]<double, void>)funcTable[622])(x);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FitPointX(double x)
		{
			FitPointXNative(x);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FitPointYNative(double y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double, void>)funcTable[623])(y);
			#else
			((delegate* unmanaged[Cdecl]<double, void>)funcTable[623])(y);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FitPointY(double y)
		{
			FitPointYNative(y);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FitPointNative(ImPlotPoint p)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotPoint, void>)funcTable[624])(p);
			#else
			((delegate* unmanaged[Cdecl]<ImPlotPoint, void>)funcTable[624])(p);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FitPoint(ImPlotPoint p)
		{
			FitPointNative(p);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte RangesOverlapNative(ImPlotRange r1, ImPlotRange r2)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotRange, ImPlotRange, byte>)funcTable[625])(r1, r2);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImPlotRange, ImPlotRange, byte>)funcTable[625])(r1, r2);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool RangesOverlap(ImPlotRange r1, ImPlotRange r2)
		{
			byte ret = RangesOverlapNative(r1, r2);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShowAxisContextMenuNative(ImPlotAxis* axis, ImPlotAxis* equalAxis, byte timeAllowed)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotAxis*, ImPlotAxis*, byte, void>)funcTable[626])(axis, equalAxis, timeAllowed);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, byte, void>)funcTable[626])((nint)axis, (nint)equalAxis, timeAllowed);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowAxisContextMenu(ImPlotAxisPtr axis, ImPlotAxisPtr equalAxis, bool timeAllowed)
		{
			ShowAxisContextMenuNative(axis, equalAxis, timeAllowed ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowAxisContextMenu(ImPlotAxisPtr axis, ImPlotAxisPtr equalAxis)
		{
			ShowAxisContextMenuNative(axis, equalAxis, (byte)(0));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowAxisContextMenu(ref ImPlotAxis axis, ImPlotAxisPtr equalAxis, bool timeAllowed)
		{
			fixed (ImPlotAxis* paxis = &axis)
			{
				ShowAxisContextMenuNative((ImPlotAxis*)paxis, equalAxis, timeAllowed ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowAxisContextMenu(ref ImPlotAxis axis, ImPlotAxisPtr equalAxis)
		{
			fixed (ImPlotAxis* paxis = &axis)
			{
				ShowAxisContextMenuNative((ImPlotAxis*)paxis, equalAxis, (byte)(0));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowAxisContextMenu(ImPlotAxisPtr axis, ref ImPlotAxis equalAxis, bool timeAllowed)
		{
			fixed (ImPlotAxis* pequalAxis = &equalAxis)
			{
				ShowAxisContextMenuNative(axis, (ImPlotAxis*)pequalAxis, timeAllowed ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowAxisContextMenu(ImPlotAxisPtr axis, ref ImPlotAxis equalAxis)
		{
			fixed (ImPlotAxis* pequalAxis = &equalAxis)
			{
				ShowAxisContextMenuNative(axis, (ImPlotAxis*)pequalAxis, (byte)(0));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowAxisContextMenu(ref ImPlotAxis axis, ref ImPlotAxis equalAxis, bool timeAllowed)
		{
			fixed (ImPlotAxis* paxis = &axis)
			{
				fixed (ImPlotAxis* pequalAxis = &equalAxis)
				{
					ShowAxisContextMenuNative((ImPlotAxis*)paxis, (ImPlotAxis*)pequalAxis, timeAllowed ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowAxisContextMenu(ref ImPlotAxis axis, ref ImPlotAxis equalAxis)
		{
			fixed (ImPlotAxis* paxis = &axis)
			{
				fixed (ImPlotAxis* pequalAxis = &equalAxis)
				{
					ShowAxisContextMenuNative((ImPlotAxis*)paxis, (ImPlotAxis*)pequalAxis, (byte)(0));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetLocationPosNative(Vector2* pOut, ImRect outerRect, Vector2 innerSize, ImPlotLocation location, Vector2 pad)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, ImRect, Vector2, ImPlotLocation, Vector2, void>)funcTable[627])(pOut, outerRect, innerSize, location, pad);
			#else
			((delegate* unmanaged[Cdecl]<nint, ImRect, Vector2, ImPlotLocation, Vector2, void>)funcTable[627])((nint)pOut, outerRect, innerSize, location, pad);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 GetLocationPos(ImRect outerRect, Vector2 innerSize, ImPlotLocation location)
		{
			Vector2 ret;
			GetLocationPosNative(&ret, outerRect, innerSize, location, (Vector2)(new Vector2(0,0)));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 GetLocationPos(ImRect outerRect, Vector2 innerSize, ImPlotLocation location, Vector2 pad)
		{
			Vector2 ret;
			GetLocationPosNative(&ret, outerRect, innerSize, location, pad);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetLocationPos(Vector2* pOut, ImRect outerRect, Vector2 innerSize, ImPlotLocation location, Vector2 pad)
		{
			GetLocationPosNative(pOut, outerRect, innerSize, location, pad);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetLocationPos(Vector2* pOut, ImRect outerRect, Vector2 innerSize, ImPlotLocation location)
		{
			GetLocationPosNative(pOut, outerRect, innerSize, location, (Vector2)(new Vector2(0,0)));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetLocationPos(ref Vector2 pOut, ImRect outerRect, Vector2 innerSize, ImPlotLocation location, Vector2 pad)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				GetLocationPosNative((Vector2*)ppOut, outerRect, innerSize, location, pad);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetLocationPos(ref Vector2 pOut, ImRect outerRect, Vector2 innerSize, ImPlotLocation location)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				GetLocationPosNative((Vector2*)ppOut, outerRect, innerSize, location, (Vector2)(new Vector2(0,0)));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CalcLegendSizeNative(Vector2* pOut, ImPlotItemGroup* items, Vector2 pad, Vector2 spacing, byte vertical)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, ImPlotItemGroup*, Vector2, Vector2, byte, void>)funcTable[628])(pOut, items, pad, spacing, vertical);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, Vector2, Vector2, byte, void>)funcTable[628])((nint)pOut, (nint)items, pad, spacing, vertical);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 CalcLegendSize(ImPlotItemGroupPtr items, Vector2 pad, Vector2 spacing, bool vertical)
		{
			Vector2 ret;
			CalcLegendSizeNative(&ret, items, pad, spacing, vertical ? (byte)1 : (byte)0);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcLegendSize(Vector2* pOut, ImPlotItemGroupPtr items, Vector2 pad, Vector2 spacing, bool vertical)
		{
			CalcLegendSizeNative(pOut, items, pad, spacing, vertical ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcLegendSize(ref Vector2 pOut, ImPlotItemGroupPtr items, Vector2 pad, Vector2 spacing, bool vertical)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				CalcLegendSizeNative((Vector2*)ppOut, items, pad, spacing, vertical ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 CalcLegendSize(ref ImPlotItemGroup items, Vector2 pad, Vector2 spacing, bool vertical)
		{
			fixed (ImPlotItemGroup* pitems = &items)
			{
				Vector2 ret;
				CalcLegendSizeNative(&ret, (ImPlotItemGroup*)pitems, pad, spacing, vertical ? (byte)1 : (byte)0);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcLegendSize(Vector2* pOut, ref ImPlotItemGroup items, Vector2 pad, Vector2 spacing, bool vertical)
		{
			fixed (ImPlotItemGroup* pitems = &items)
			{
				CalcLegendSizeNative(pOut, (ImPlotItemGroup*)pitems, pad, spacing, vertical ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcLegendSize(ref Vector2 pOut, ref ImPlotItemGroup items, Vector2 pad, Vector2 spacing, bool vertical)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (ImPlotItemGroup* pitems = &items)
				{
					CalcLegendSizeNative((Vector2*)ppOut, (ImPlotItemGroup*)pitems, pad, spacing, vertical ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ClampLegendRectNative(ImRect* legendRect, ImRect outerRect, Vector2 pad)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImRect*, ImRect, Vector2, byte>)funcTable[629])(legendRect, outerRect, pad);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, ImRect, Vector2, byte>)funcTable[629])((nint)legendRect, outerRect, pad);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ClampLegendRect(ImRectPtr legendRect, ImRect outerRect, Vector2 pad)
		{
			byte ret = ClampLegendRectNative(legendRect, outerRect, pad);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ClampLegendRect(ref ImRect legendRect, ImRect outerRect, Vector2 pad)
		{
			fixed (ImRect* plegendRect = &legendRect)
			{
				byte ret = ClampLegendRectNative((ImRect*)plegendRect, outerRect, pad);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ShowLegendEntriesNative(ImPlotItemGroup* items, ImRect legendBb, byte interactable, Vector2 pad, Vector2 spacing, byte vertical, ImDrawList* drawList)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotItemGroup*, ImRect, byte, Vector2, Vector2, byte, ImDrawList*, byte>)funcTable[630])(items, legendBb, interactable, pad, spacing, vertical, drawList);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, ImRect, byte, Vector2, Vector2, byte, nint, byte>)funcTable[630])((nint)items, legendBb, interactable, pad, spacing, vertical, (nint)drawList);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowLegendEntries(ImPlotItemGroupPtr items, ImRect legendBb, bool interactable, Vector2 pad, Vector2 spacing, bool vertical, ImDrawListPtr drawList)
		{
			byte ret = ShowLegendEntriesNative(items, legendBb, interactable ? (byte)1 : (byte)0, pad, spacing, vertical ? (byte)1 : (byte)0, drawList);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowLegendEntries(ref ImPlotItemGroup items, ImRect legendBb, bool interactable, Vector2 pad, Vector2 spacing, bool vertical, ImDrawListPtr drawList)
		{
			fixed (ImPlotItemGroup* pitems = &items)
			{
				byte ret = ShowLegendEntriesNative((ImPlotItemGroup*)pitems, legendBb, interactable ? (byte)1 : (byte)0, pad, spacing, vertical ? (byte)1 : (byte)0, drawList);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowLegendEntries(ImPlotItemGroupPtr items, ImRect legendBb, bool interactable, Vector2 pad, Vector2 spacing, bool vertical, ref ImDrawList drawList)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte ret = ShowLegendEntriesNative(items, legendBb, interactable ? (byte)1 : (byte)0, pad, spacing, vertical ? (byte)1 : (byte)0, (ImDrawList*)pdrawList);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowLegendEntries(ref ImPlotItemGroup items, ImRect legendBb, bool interactable, Vector2 pad, Vector2 spacing, bool vertical, ref ImDrawList drawList)
		{
			fixed (ImPlotItemGroup* pitems = &items)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte ret = ShowLegendEntriesNative((ImPlotItemGroup*)pitems, legendBb, interactable ? (byte)1 : (byte)0, pad, spacing, vertical ? (byte)1 : (byte)0, (ImDrawList*)pdrawList);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShowAltLegendNative(byte* titleId, byte vertical, Vector2 size, byte interactable)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, byte, Vector2, byte, void>)funcTable[631])(titleId, vertical, size, interactable);
			#else
			((delegate* unmanaged[Cdecl]<nint, byte, Vector2, byte, void>)funcTable[631])((nint)titleId, vertical, size, interactable);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowAltLegend(byte* titleId, bool vertical, Vector2 size, bool interactable)
		{
			ShowAltLegendNative(titleId, vertical ? (byte)1 : (byte)0, size, interactable ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowAltLegend(byte* titleId, bool vertical, Vector2 size)
		{
			ShowAltLegendNative(titleId, vertical ? (byte)1 : (byte)0, size, (byte)(1));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowAltLegend(byte* titleId, bool vertical)
		{
			ShowAltLegendNative(titleId, vertical ? (byte)1 : (byte)0, (Vector2)(new Vector2(0,0)), (byte)(1));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowAltLegend(byte* titleId)
		{
			ShowAltLegendNative(titleId, (byte)(1), (Vector2)(new Vector2(0,0)), (byte)(1));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowAltLegend(byte* titleId, Vector2 size)
		{
			ShowAltLegendNative(titleId, (byte)(1), size, (byte)(1));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowAltLegend(byte* titleId, bool vertical, bool interactable)
		{
			ShowAltLegendNative(titleId, vertical ? (byte)1 : (byte)0, (Vector2)(new Vector2(0,0)), interactable ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowAltLegend(byte* titleId, Vector2 size, bool interactable)
		{
			ShowAltLegendNative(titleId, (byte)(1), size, interactable ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowAltLegend(ref byte titleId, bool vertical, Vector2 size, bool interactable)
		{
			fixed (byte* ptitleId = &titleId)
			{
				ShowAltLegendNative((byte*)ptitleId, vertical ? (byte)1 : (byte)0, size, interactable ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowAltLegend(ref byte titleId, bool vertical, Vector2 size)
		{
			fixed (byte* ptitleId = &titleId)
			{
				ShowAltLegendNative((byte*)ptitleId, vertical ? (byte)1 : (byte)0, size, (byte)(1));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowAltLegend(ref byte titleId, bool vertical)
		{
			fixed (byte* ptitleId = &titleId)
			{
				ShowAltLegendNative((byte*)ptitleId, vertical ? (byte)1 : (byte)0, (Vector2)(new Vector2(0,0)), (byte)(1));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowAltLegend(ref byte titleId)
		{
			fixed (byte* ptitleId = &titleId)
			{
				ShowAltLegendNative((byte*)ptitleId, (byte)(1), (Vector2)(new Vector2(0,0)), (byte)(1));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowAltLegend(ref byte titleId, Vector2 size)
		{
			fixed (byte* ptitleId = &titleId)
			{
				ShowAltLegendNative((byte*)ptitleId, (byte)(1), size, (byte)(1));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowAltLegend(ref byte titleId, bool vertical, bool interactable)
		{
			fixed (byte* ptitleId = &titleId)
			{
				ShowAltLegendNative((byte*)ptitleId, vertical ? (byte)1 : (byte)0, (Vector2)(new Vector2(0,0)), interactable ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowAltLegend(ref byte titleId, Vector2 size, bool interactable)
		{
			fixed (byte* ptitleId = &titleId)
			{
				ShowAltLegendNative((byte*)ptitleId, (byte)(1), size, interactable ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowAltLegend(ReadOnlySpan<byte> titleId, bool vertical, Vector2 size, bool interactable)
		{
			fixed (byte* ptitleId = titleId)
			{
				ShowAltLegendNative((byte*)ptitleId, vertical ? (byte)1 : (byte)0, size, interactable ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowAltLegend(ReadOnlySpan<byte> titleId, bool vertical, Vector2 size)
		{
			fixed (byte* ptitleId = titleId)
			{
				ShowAltLegendNative((byte*)ptitleId, vertical ? (byte)1 : (byte)0, size, (byte)(1));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowAltLegend(ReadOnlySpan<byte> titleId, bool vertical)
		{
			fixed (byte* ptitleId = titleId)
			{
				ShowAltLegendNative((byte*)ptitleId, vertical ? (byte)1 : (byte)0, (Vector2)(new Vector2(0,0)), (byte)(1));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowAltLegend(ReadOnlySpan<byte> titleId)
		{
			fixed (byte* ptitleId = titleId)
			{
				ShowAltLegendNative((byte*)ptitleId, (byte)(1), (Vector2)(new Vector2(0,0)), (byte)(1));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowAltLegend(ReadOnlySpan<byte> titleId, Vector2 size)
		{
			fixed (byte* ptitleId = titleId)
			{
				ShowAltLegendNative((byte*)ptitleId, (byte)(1), size, (byte)(1));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowAltLegend(ReadOnlySpan<byte> titleId, bool vertical, bool interactable)
		{
			fixed (byte* ptitleId = titleId)
			{
				ShowAltLegendNative((byte*)ptitleId, vertical ? (byte)1 : (byte)0, (Vector2)(new Vector2(0,0)), interactable ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowAltLegend(ReadOnlySpan<byte> titleId, Vector2 size, bool interactable)
		{
			fixed (byte* ptitleId = titleId)
			{
				ShowAltLegendNative((byte*)ptitleId, (byte)(1), size, interactable ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowAltLegend(string titleId, bool vertical, Vector2 size, bool interactable)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (titleId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(titleId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(titleId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShowAltLegendNative(pStr0, vertical ? (byte)1 : (byte)0, size, interactable ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowAltLegend(string titleId, bool vertical, Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (titleId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(titleId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(titleId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShowAltLegendNative(pStr0, vertical ? (byte)1 : (byte)0, size, (byte)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowAltLegend(string titleId, bool vertical)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (titleId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(titleId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(titleId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShowAltLegendNative(pStr0, vertical ? (byte)1 : (byte)0, (Vector2)(new Vector2(0,0)), (byte)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowAltLegend(string titleId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (titleId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(titleId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(titleId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShowAltLegendNative(pStr0, (byte)(1), (Vector2)(new Vector2(0,0)), (byte)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowAltLegend(string titleId, Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (titleId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(titleId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(titleId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShowAltLegendNative(pStr0, (byte)(1), size, (byte)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowAltLegend(string titleId, bool vertical, bool interactable)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (titleId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(titleId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(titleId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShowAltLegendNative(pStr0, vertical ? (byte)1 : (byte)0, (Vector2)(new Vector2(0,0)), interactable ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowAltLegend(string titleId, Vector2 size, bool interactable)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (titleId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(titleId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(titleId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShowAltLegendNative(pStr0, (byte)(1), size, interactable ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ShowLegendContextMenuNative(ImPlotLegend* legend, byte visible)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotLegend*, byte, byte>)funcTable[632])(legend, visible);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte, byte>)funcTable[632])((nint)legend, visible);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowLegendContextMenu(ImPlotLegendPtr legend, bool visible)
		{
			byte ret = ShowLegendContextMenuNative(legend, visible ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowLegendContextMenu(ref ImPlotLegend legend, bool visible)
		{
			fixed (ImPlotLegend* plegend = &legend)
			{
				byte ret = ShowLegendContextMenuNative((ImPlotLegend*)plegend, visible ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LabelAxisValueNative(ImPlotAxis axis, double value, byte* buff, int size, byte round)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotAxis, double, byte*, int, byte, void>)funcTable[633])(axis, value, buff, size, round);
			#else
			((delegate* unmanaged[Cdecl]<ImPlotAxis, double, nint, int, byte, void>)funcTable[633])(axis, value, (nint)buff, size, round);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LabelAxisValue(ImPlotAxis axis, double value, byte* buff, int size, bool round)
		{
			LabelAxisValueNative(axis, value, buff, size, round ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LabelAxisValue(ImPlotAxis axis, double value, byte* buff, int size)
		{
			LabelAxisValueNative(axis, value, buff, size, (byte)(0));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LabelAxisValue(ImPlotAxis axis, double value, ref byte buff, int size, bool round)
		{
			fixed (byte* pbuff = &buff)
			{
				LabelAxisValueNative(axis, value, (byte*)pbuff, size, round ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LabelAxisValue(ImPlotAxis axis, double value, ref byte buff, int size)
		{
			fixed (byte* pbuff = &buff)
			{
				LabelAxisValueNative(axis, value, (byte*)pbuff, size, (byte)(0));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LabelAxisValue(ImPlotAxis axis, double value, ref string buff, int size, bool round)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buff != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buff);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buff, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LabelAxisValueNative(axis, value, pStr0, size, round ? (byte)1 : (byte)0);
			buff = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LabelAxisValue(ImPlotAxis axis, double value, ref string buff, int size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buff != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buff);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buff, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LabelAxisValueNative(axis, value, pStr0, size, (byte)(0));
			buff = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImPlotNextItemData* GetItemDataNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotNextItemData*>)funcTable[634])();
			#else
			return (ImPlotNextItemData*)((delegate* unmanaged[Cdecl]<nint>)funcTable[634])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotNextItemDataPtr GetItemData()
		{
			ImPlotNextItemDataPtr ret = GetItemDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsColorAutoNative(Vector4 col)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector4, byte>)funcTable[635])(col);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<Vector4, byte>)funcTable[635])(col);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsColorAuto(Vector4 col)
		{
			byte ret = IsColorAutoNative(col);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsColorAutoNative(ImPlotCol idx)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotCol, byte>)funcTable[636])(idx);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImPlotCol, byte>)funcTable[636])(idx);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsColorAuto(ImPlotCol idx)
		{
			byte ret = IsColorAutoNative(idx);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetAutoColorNative(Vector4* pOut, ImPlotCol idx)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector4*, ImPlotCol, void>)funcTable[637])(pOut, idx);
			#else
			((delegate* unmanaged[Cdecl]<nint, ImPlotCol, void>)funcTable[637])((nint)pOut, idx);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector4 GetAutoColor(ImPlotCol idx)
		{
			Vector4 ret;
			GetAutoColorNative(&ret, idx);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetAutoColor(Vector4* pOut, ImPlotCol idx)
		{
			GetAutoColorNative(pOut, idx);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetAutoColor(ref Vector4 pOut, ImPlotCol idx)
		{
			fixed (Vector4* ppOut = &pOut)
			{
				GetAutoColorNative((Vector4*)ppOut, idx);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetStyleColorVec4Native(Vector4* pOut, ImPlotCol idx)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector4*, ImPlotCol, void>)funcTable[638])(pOut, idx);
			#else
			((delegate* unmanaged[Cdecl]<nint, ImPlotCol, void>)funcTable[638])((nint)pOut, idx);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector4 GetStyleColorVec4(ImPlotCol idx)
		{
			Vector4 ret;
			GetStyleColorVec4Native(&ret, idx);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetStyleColorVec4(Vector4* pOut, ImPlotCol idx)
		{
			GetStyleColorVec4Native(pOut, idx);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetStyleColorVec4(ref Vector4 pOut, ImPlotCol idx)
		{
			fixed (Vector4* ppOut = &pOut)
			{
				GetStyleColorVec4Native((Vector4*)ppOut, idx);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetStyleColorU32Native(ImPlotCol idx)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotCol, uint>)funcTable[639])(idx);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<ImPlotCol, uint>)funcTable[639])(idx);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetStyleColorU32(ImPlotCol idx)
		{
			uint ret = GetStyleColorU32Native(idx);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void AddTextVerticalNative(ImDrawList* drawList, Vector2 pos, uint col, byte* textBegin, byte* textEnd)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImDrawList*, Vector2, uint, byte*, byte*, void>)funcTable[640])(drawList, pos, col, textBegin, textEnd);
			#else
			((delegate* unmanaged[Cdecl]<nint, Vector2, uint, nint, nint, void>)funcTable[640])((nint)drawList, pos, col, (nint)textBegin, (nint)textEnd);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextVertical(ImDrawListPtr drawList, Vector2 pos, uint col, byte* textBegin, byte* textEnd)
		{
			AddTextVerticalNative(drawList, pos, col, textBegin, textEnd);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextVertical(ImDrawListPtr drawList, Vector2 pos, uint col, byte* textBegin)
		{
			AddTextVerticalNative(drawList, pos, col, textBegin, (byte*)(default));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextVertical(ref ImDrawList drawList, Vector2 pos, uint col, byte* textBegin, byte* textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				AddTextVerticalNative((ImDrawList*)pdrawList, pos, col, textBegin, textEnd);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextVertical(ref ImDrawList drawList, Vector2 pos, uint col, byte* textBegin)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				AddTextVerticalNative((ImDrawList*)pdrawList, pos, col, textBegin, (byte*)(default));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextVertical(ImDrawListPtr drawList, Vector2 pos, uint col, ref byte textBegin, byte* textEnd)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				AddTextVerticalNative(drawList, pos, col, (byte*)ptextBegin, textEnd);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextVertical(ImDrawListPtr drawList, Vector2 pos, uint col, ref byte textBegin)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				AddTextVerticalNative(drawList, pos, col, (byte*)ptextBegin, (byte*)(default));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextVertical(ImDrawListPtr drawList, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, byte* textEnd)
		{
			fixed (byte* ptextBegin = textBegin)
			{
				AddTextVerticalNative(drawList, pos, col, (byte*)ptextBegin, textEnd);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextVertical(ImDrawListPtr drawList, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin)
		{
			fixed (byte* ptextBegin = textBegin)
			{
				AddTextVerticalNative(drawList, pos, col, (byte*)ptextBegin, (byte*)(default));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextVertical(ImDrawListPtr drawList, Vector2 pos, uint col, string textBegin, byte* textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AddTextVerticalNative(drawList, pos, col, pStr0, textEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextVertical(ImDrawListPtr drawList, Vector2 pos, uint col, string textBegin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AddTextVerticalNative(drawList, pos, col, pStr0, (byte*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextVertical(ref ImDrawList drawList, Vector2 pos, uint col, ref byte textBegin, byte* textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					AddTextVerticalNative((ImDrawList*)pdrawList, pos, col, (byte*)ptextBegin, textEnd);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextVertical(ref ImDrawList drawList, Vector2 pos, uint col, ref byte textBegin)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					AddTextVerticalNative((ImDrawList*)pdrawList, pos, col, (byte*)ptextBegin, (byte*)(default));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextVertical(ref ImDrawList drawList, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, byte* textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					AddTextVerticalNative((ImDrawList*)pdrawList, pos, col, (byte*)ptextBegin, textEnd);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextVertical(ref ImDrawList drawList, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					AddTextVerticalNative((ImDrawList*)pdrawList, pos, col, (byte*)ptextBegin, (byte*)(default));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextVertical(ref ImDrawList drawList, Vector2 pos, uint col, string textBegin, byte* textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AddTextVerticalNative((ImDrawList*)pdrawList, pos, col, pStr0, textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextVertical(ref ImDrawList drawList, Vector2 pos, uint col, string textBegin)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AddTextVerticalNative((ImDrawList*)pdrawList, pos, col, pStr0, (byte*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextVertical(ImDrawListPtr drawList, Vector2 pos, uint col, byte* textBegin, ref byte textEnd)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				AddTextVerticalNative(drawList, pos, col, textBegin, (byte*)ptextEnd);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextVertical(ImDrawListPtr drawList, Vector2 pos, uint col, byte* textBegin, ReadOnlySpan<byte> textEnd)
		{
			fixed (byte* ptextEnd = textEnd)
			{
				AddTextVerticalNative(drawList, pos, col, textBegin, (byte*)ptextEnd);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextVertical(ImDrawListPtr drawList, Vector2 pos, uint col, byte* textBegin, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AddTextVerticalNative(drawList, pos, col, textBegin, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextVertical(ref ImDrawList drawList, Vector2 pos, uint col, byte* textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					AddTextVerticalNative((ImDrawList*)pdrawList, pos, col, textBegin, (byte*)ptextEnd);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextVertical(ref ImDrawList drawList, Vector2 pos, uint col, byte* textBegin, ReadOnlySpan<byte> textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextEnd = textEnd)
				{
					AddTextVerticalNative((ImDrawList*)pdrawList, pos, col, textBegin, (byte*)ptextEnd);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextVertical(ref ImDrawList drawList, Vector2 pos, uint col, byte* textBegin, string textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AddTextVerticalNative((ImDrawList*)pdrawList, pos, col, textBegin, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextVertical(ImDrawListPtr drawList, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					AddTextVerticalNative(drawList, pos, col, (byte*)ptextBegin, (byte*)ptextEnd);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextVertical(ImDrawListPtr drawList, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, ReadOnlySpan<byte> textEnd)
		{
			fixed (byte* ptextBegin = textBegin)
			{
				fixed (byte* ptextEnd = textEnd)
				{
					AddTextVerticalNative(drawList, pos, col, (byte*)ptextBegin, (byte*)ptextEnd);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextVertical(ImDrawListPtr drawList, Vector2 pos, uint col, string textBegin, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			AddTextVerticalNative(drawList, pos, col, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextVertical(ImDrawListPtr drawList, Vector2 pos, uint col, ref byte textBegin, ReadOnlySpan<byte> textEnd)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = textEnd)
				{
					AddTextVerticalNative(drawList, pos, col, (byte*)ptextBegin, (byte*)ptextEnd);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextVertical(ImDrawListPtr drawList, Vector2 pos, uint col, ref byte textBegin, string textEnd)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AddTextVerticalNative(drawList, pos, col, (byte*)ptextBegin, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextVertical(ImDrawListPtr drawList, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, ref byte textEnd)
		{
			fixed (byte* ptextBegin = textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					AddTextVerticalNative(drawList, pos, col, (byte*)ptextBegin, (byte*)ptextEnd);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextVertical(ImDrawListPtr drawList, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, string textEnd)
		{
			fixed (byte* ptextBegin = textBegin)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AddTextVerticalNative(drawList, pos, col, (byte*)ptextBegin, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextVertical(ImDrawListPtr drawList, Vector2 pos, uint col, string textBegin, ref byte textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* ptextEnd = &textEnd)
			{
				AddTextVerticalNative(drawList, pos, col, pStr0, (byte*)ptextEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextVertical(ImDrawListPtr drawList, Vector2 pos, uint col, string textBegin, ReadOnlySpan<byte> textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* ptextEnd = textEnd)
			{
				AddTextVerticalNative(drawList, pos, col, pStr0, (byte*)ptextEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextVertical(ref ImDrawList drawList, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						AddTextVerticalNative((ImDrawList*)pdrawList, pos, col, (byte*)ptextBegin, (byte*)ptextEnd);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextVertical(ref ImDrawList drawList, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, ReadOnlySpan<byte> textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					fixed (byte* ptextEnd = textEnd)
					{
						AddTextVerticalNative((ImDrawList*)pdrawList, pos, col, (byte*)ptextBegin, (byte*)ptextEnd);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextVertical(ref ImDrawList drawList, Vector2 pos, uint col, string textBegin, string textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				AddTextVerticalNative((ImDrawList*)pdrawList, pos, col, pStr0, pStr1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextVertical(ref ImDrawList drawList, Vector2 pos, uint col, ref byte textBegin, ReadOnlySpan<byte> textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = textEnd)
					{
						AddTextVerticalNative((ImDrawList*)pdrawList, pos, col, (byte*)ptextBegin, (byte*)ptextEnd);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextVertical(ref ImDrawList drawList, Vector2 pos, uint col, ref byte textBegin, string textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					AddTextVerticalNative((ImDrawList*)pdrawList, pos, col, (byte*)ptextBegin, pStr0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextVertical(ref ImDrawList drawList, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						AddTextVerticalNative((ImDrawList*)pdrawList, pos, col, (byte*)ptextBegin, (byte*)ptextEnd);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextVertical(ref ImDrawList drawList, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, string textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					AddTextVerticalNative((ImDrawList*)pdrawList, pos, col, (byte*)ptextBegin, pStr0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextVertical(ref ImDrawList drawList, Vector2 pos, uint col, string textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* ptextEnd = &textEnd)
				{
					AddTextVerticalNative((ImDrawList*)pdrawList, pos, col, pStr0, (byte*)ptextEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextVertical(ref ImDrawList drawList, Vector2 pos, uint col, string textBegin, ReadOnlySpan<byte> textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* ptextEnd = textEnd)
				{
					AddTextVerticalNative((ImDrawList*)pdrawList, pos, col, pStr0, (byte*)ptextEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void AddTextCenteredNative(ImDrawList* drawList, Vector2 topCenter, uint col, byte* textBegin, byte* textEnd)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImDrawList*, Vector2, uint, byte*, byte*, void>)funcTable[641])(drawList, topCenter, col, textBegin, textEnd);
			#else
			((delegate* unmanaged[Cdecl]<nint, Vector2, uint, nint, nint, void>)funcTable[641])((nint)drawList, topCenter, col, (nint)textBegin, (nint)textEnd);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ImDrawListPtr drawList, Vector2 topCenter, uint col, byte* textBegin, byte* textEnd)
		{
			AddTextCenteredNative(drawList, topCenter, col, textBegin, textEnd);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ImDrawListPtr drawList, Vector2 topCenter, uint col, byte* textBegin)
		{
			AddTextCenteredNative(drawList, topCenter, col, textBegin, (byte*)(default));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ref ImDrawList drawList, Vector2 topCenter, uint col, byte* textBegin, byte* textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				AddTextCenteredNative((ImDrawList*)pdrawList, topCenter, col, textBegin, textEnd);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ref ImDrawList drawList, Vector2 topCenter, uint col, byte* textBegin)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				AddTextCenteredNative((ImDrawList*)pdrawList, topCenter, col, textBegin, (byte*)(default));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ImDrawListPtr drawList, Vector2 topCenter, uint col, ref byte textBegin, byte* textEnd)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				AddTextCenteredNative(drawList, topCenter, col, (byte*)ptextBegin, textEnd);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ImDrawListPtr drawList, Vector2 topCenter, uint col, ref byte textBegin)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				AddTextCenteredNative(drawList, topCenter, col, (byte*)ptextBegin, (byte*)(default));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ImDrawListPtr drawList, Vector2 topCenter, uint col, ReadOnlySpan<byte> textBegin, byte* textEnd)
		{
			fixed (byte* ptextBegin = textBegin)
			{
				AddTextCenteredNative(drawList, topCenter, col, (byte*)ptextBegin, textEnd);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ImDrawListPtr drawList, Vector2 topCenter, uint col, ReadOnlySpan<byte> textBegin)
		{
			fixed (byte* ptextBegin = textBegin)
			{
				AddTextCenteredNative(drawList, topCenter, col, (byte*)ptextBegin, (byte*)(default));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ImDrawListPtr drawList, Vector2 topCenter, uint col, string textBegin, byte* textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AddTextCenteredNative(drawList, topCenter, col, pStr0, textEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ImDrawListPtr drawList, Vector2 topCenter, uint col, string textBegin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AddTextCenteredNative(drawList, topCenter, col, pStr0, (byte*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ref ImDrawList drawList, Vector2 topCenter, uint col, ref byte textBegin, byte* textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					AddTextCenteredNative((ImDrawList*)pdrawList, topCenter, col, (byte*)ptextBegin, textEnd);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ref ImDrawList drawList, Vector2 topCenter, uint col, ref byte textBegin)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					AddTextCenteredNative((ImDrawList*)pdrawList, topCenter, col, (byte*)ptextBegin, (byte*)(default));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ref ImDrawList drawList, Vector2 topCenter, uint col, ReadOnlySpan<byte> textBegin, byte* textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					AddTextCenteredNative((ImDrawList*)pdrawList, topCenter, col, (byte*)ptextBegin, textEnd);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ref ImDrawList drawList, Vector2 topCenter, uint col, ReadOnlySpan<byte> textBegin)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					AddTextCenteredNative((ImDrawList*)pdrawList, topCenter, col, (byte*)ptextBegin, (byte*)(default));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ref ImDrawList drawList, Vector2 topCenter, uint col, string textBegin, byte* textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AddTextCenteredNative((ImDrawList*)pdrawList, topCenter, col, pStr0, textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ref ImDrawList drawList, Vector2 topCenter, uint col, string textBegin)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AddTextCenteredNative((ImDrawList*)pdrawList, topCenter, col, pStr0, (byte*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ImDrawListPtr drawList, Vector2 topCenter, uint col, byte* textBegin, ref byte textEnd)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				AddTextCenteredNative(drawList, topCenter, col, textBegin, (byte*)ptextEnd);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ImDrawListPtr drawList, Vector2 topCenter, uint col, byte* textBegin, ReadOnlySpan<byte> textEnd)
		{
			fixed (byte* ptextEnd = textEnd)
			{
				AddTextCenteredNative(drawList, topCenter, col, textBegin, (byte*)ptextEnd);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ImDrawListPtr drawList, Vector2 topCenter, uint col, byte* textBegin, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AddTextCenteredNative(drawList, topCenter, col, textBegin, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ref ImDrawList drawList, Vector2 topCenter, uint col, byte* textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					AddTextCenteredNative((ImDrawList*)pdrawList, topCenter, col, textBegin, (byte*)ptextEnd);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ref ImDrawList drawList, Vector2 topCenter, uint col, byte* textBegin, ReadOnlySpan<byte> textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextEnd = textEnd)
				{
					AddTextCenteredNative((ImDrawList*)pdrawList, topCenter, col, textBegin, (byte*)ptextEnd);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ref ImDrawList drawList, Vector2 topCenter, uint col, byte* textBegin, string textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AddTextCenteredNative((ImDrawList*)pdrawList, topCenter, col, textBegin, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ImDrawListPtr drawList, Vector2 topCenter, uint col, ref byte textBegin, ref byte textEnd)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					AddTextCenteredNative(drawList, topCenter, col, (byte*)ptextBegin, (byte*)ptextEnd);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ImDrawListPtr drawList, Vector2 topCenter, uint col, ReadOnlySpan<byte> textBegin, ReadOnlySpan<byte> textEnd)
		{
			fixed (byte* ptextBegin = textBegin)
			{
				fixed (byte* ptextEnd = textEnd)
				{
					AddTextCenteredNative(drawList, topCenter, col, (byte*)ptextBegin, (byte*)ptextEnd);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ImDrawListPtr drawList, Vector2 topCenter, uint col, string textBegin, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			AddTextCenteredNative(drawList, topCenter, col, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ImDrawListPtr drawList, Vector2 topCenter, uint col, ref byte textBegin, ReadOnlySpan<byte> textEnd)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = textEnd)
				{
					AddTextCenteredNative(drawList, topCenter, col, (byte*)ptextBegin, (byte*)ptextEnd);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ImDrawListPtr drawList, Vector2 topCenter, uint col, ref byte textBegin, string textEnd)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AddTextCenteredNative(drawList, topCenter, col, (byte*)ptextBegin, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ImDrawListPtr drawList, Vector2 topCenter, uint col, ReadOnlySpan<byte> textBegin, ref byte textEnd)
		{
			fixed (byte* ptextBegin = textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					AddTextCenteredNative(drawList, topCenter, col, (byte*)ptextBegin, (byte*)ptextEnd);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ImDrawListPtr drawList, Vector2 topCenter, uint col, ReadOnlySpan<byte> textBegin, string textEnd)
		{
			fixed (byte* ptextBegin = textBegin)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AddTextCenteredNative(drawList, topCenter, col, (byte*)ptextBegin, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ImDrawListPtr drawList, Vector2 topCenter, uint col, string textBegin, ref byte textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* ptextEnd = &textEnd)
			{
				AddTextCenteredNative(drawList, topCenter, col, pStr0, (byte*)ptextEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ImDrawListPtr drawList, Vector2 topCenter, uint col, string textBegin, ReadOnlySpan<byte> textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* ptextEnd = textEnd)
			{
				AddTextCenteredNative(drawList, topCenter, col, pStr0, (byte*)ptextEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ref ImDrawList drawList, Vector2 topCenter, uint col, ref byte textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						AddTextCenteredNative((ImDrawList*)pdrawList, topCenter, col, (byte*)ptextBegin, (byte*)ptextEnd);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ref ImDrawList drawList, Vector2 topCenter, uint col, ReadOnlySpan<byte> textBegin, ReadOnlySpan<byte> textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					fixed (byte* ptextEnd = textEnd)
					{
						AddTextCenteredNative((ImDrawList*)pdrawList, topCenter, col, (byte*)ptextBegin, (byte*)ptextEnd);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ref ImDrawList drawList, Vector2 topCenter, uint col, string textBegin, string textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				AddTextCenteredNative((ImDrawList*)pdrawList, topCenter, col, pStr0, pStr1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ref ImDrawList drawList, Vector2 topCenter, uint col, ref byte textBegin, ReadOnlySpan<byte> textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = textEnd)
					{
						AddTextCenteredNative((ImDrawList*)pdrawList, topCenter, col, (byte*)ptextBegin, (byte*)ptextEnd);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ref ImDrawList drawList, Vector2 topCenter, uint col, ref byte textBegin, string textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					AddTextCenteredNative((ImDrawList*)pdrawList, topCenter, col, (byte*)ptextBegin, pStr0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ref ImDrawList drawList, Vector2 topCenter, uint col, ReadOnlySpan<byte> textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						AddTextCenteredNative((ImDrawList*)pdrawList, topCenter, col, (byte*)ptextBegin, (byte*)ptextEnd);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ref ImDrawList drawList, Vector2 topCenter, uint col, ReadOnlySpan<byte> textBegin, string textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					AddTextCenteredNative((ImDrawList*)pdrawList, topCenter, col, (byte*)ptextBegin, pStr0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ref ImDrawList drawList, Vector2 topCenter, uint col, string textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* ptextEnd = &textEnd)
				{
					AddTextCenteredNative((ImDrawList*)pdrawList, topCenter, col, pStr0, (byte*)ptextEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ref ImDrawList drawList, Vector2 topCenter, uint col, string textBegin, ReadOnlySpan<byte> textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* ptextEnd = textEnd)
				{
					AddTextCenteredNative((ImDrawList*)pdrawList, topCenter, col, pStr0, (byte*)ptextEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CalcTextSizeVerticalNative(Vector2* pOut, byte* text)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, byte*, void>)funcTable[642])(pOut, text);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[642])((nint)pOut, (nint)text);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 CalcTextSizeVertical(byte* text)
		{
			Vector2 ret;
			CalcTextSizeVerticalNative(&ret, text);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSizeVertical(Vector2* pOut, byte* text)
		{
			CalcTextSizeVerticalNative(pOut, text);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSizeVertical(ref Vector2 pOut, byte* text)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				CalcTextSizeVerticalNative((Vector2*)ppOut, text);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 CalcTextSizeVertical(ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				Vector2 ret;
				CalcTextSizeVerticalNative(&ret, (byte*)ptext);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 CalcTextSizeVertical(ReadOnlySpan<byte> text)
		{
			fixed (byte* ptext = text)
			{
				Vector2 ret;
				CalcTextSizeVerticalNative(&ret, (byte*)ptext);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 CalcTextSizeVertical(string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Vector2 ret;
			CalcTextSizeVerticalNative(&ret, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSizeVertical(ref Vector2 pOut, ref byte text)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (byte* ptext = &text)
				{
					CalcTextSizeVerticalNative((Vector2*)ppOut, (byte*)ptext);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSizeVertical(ref Vector2 pOut, ReadOnlySpan<byte> text)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (byte* ptext = text)
				{
					CalcTextSizeVerticalNative((Vector2*)ppOut, (byte*)ptext);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSizeVertical(ref Vector2 pOut, string text)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				CalcTextSizeVerticalNative((Vector2*)ppOut, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint CalcTextColorNative(Vector4 bg)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector4, uint>)funcTable[643])(bg);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<Vector4, uint>)funcTable[643])(bg);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint CalcTextColor(Vector4 bg)
		{
			uint ret = CalcTextColorNative(bg);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint CalcTextColorNative(uint bg)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, uint>)funcTable[644])(bg);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint, uint>)funcTable[644])(bg);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint CalcTextColor(uint bg)
		{
			uint ret = CalcTextColorNative(bg);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint CalcHoverColorNative(uint col)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, uint>)funcTable[645])(col);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint, uint>)funcTable[645])(col);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint CalcHoverColor(uint col)
		{
			uint ret = CalcHoverColorNative(col);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClampLabelPosNative(Vector2* pOut, Vector2 pos, Vector2 size, Vector2 min, Vector2 max)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, Vector2, Vector2, Vector2, Vector2, void>)funcTable[646])(pOut, pos, size, min, max);
			#else
			((delegate* unmanaged[Cdecl]<nint, Vector2, Vector2, Vector2, Vector2, void>)funcTable[646])((nint)pOut, pos, size, min, max);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 ClampLabelPos(Vector2 pos, Vector2 size, Vector2 min, Vector2 max)
		{
			Vector2 ret;
			ClampLabelPosNative(&ret, pos, size, min, max);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClampLabelPos(Vector2* pOut, Vector2 pos, Vector2 size, Vector2 min, Vector2 max)
		{
			ClampLabelPosNative(pOut, pos, size, min, max);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClampLabelPos(ref Vector2 pOut, Vector2 pos, Vector2 size, Vector2 min, Vector2 max)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ClampLabelPosNative((Vector2*)ppOut, pos, size, min, max);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetColormapColorU32Native(int idx, ImPlotColormap cmap)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, ImPlotColormap, uint>)funcTable[647])(idx, cmap);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<int, ImPlotColormap, uint>)funcTable[647])(idx, cmap);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetColormapColorU32(int idx, ImPlotColormap cmap)
		{
			uint ret = GetColormapColorU32Native(idx, cmap);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint NextColormapColorU32Native()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint>)funcTable[648])();
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint>)funcTable[648])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint NextColormapColorU32()
		{
			uint ret = NextColormapColorU32Native();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint SampleColormapU32Native(float t, ImPlotColormap cmap)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, ImPlotColormap, uint>)funcTable[649])(t, cmap);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<float, ImPlotColormap, uint>)funcTable[649])(t, cmap);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint SampleColormapU32(float t, ImPlotColormap cmap)
		{
			uint ret = SampleColormapU32Native(t, cmap);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RenderColorBarNative(uint* colors, int size, ImDrawList* drawList, ImRect bounds, byte vert, byte reversed, byte continuous)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint*, int, ImDrawList*, ImRect, byte, byte, byte, void>)funcTable[650])(colors, size, drawList, bounds, vert, reversed, continuous);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, nint, ImRect, byte, byte, byte, void>)funcTable[650])((nint)colors, size, (nint)drawList, bounds, vert, reversed, continuous);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void RenderColorBar(uint* colors, int size, ImDrawListPtr drawList, ImRect bounds, bool vert, bool reversed, bool continuous)
		{
			RenderColorBarNative(colors, size, drawList, bounds, vert ? (byte)1 : (byte)0, reversed ? (byte)1 : (byte)0, continuous ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void RenderColorBar(ref uint colors, int size, ImDrawListPtr drawList, ImRect bounds, bool vert, bool reversed, bool continuous)
		{
			fixed (uint* pcolors = &colors)
			{
				RenderColorBarNative((uint*)pcolors, size, drawList, bounds, vert ? (byte)1 : (byte)0, reversed ? (byte)1 : (byte)0, continuous ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void RenderColorBar(uint* colors, int size, ref ImDrawList drawList, ImRect bounds, bool vert, bool reversed, bool continuous)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				RenderColorBarNative(colors, size, (ImDrawList*)pdrawList, bounds, vert ? (byte)1 : (byte)0, reversed ? (byte)1 : (byte)0, continuous ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void RenderColorBar(ref uint colors, int size, ref ImDrawList drawList, ImRect bounds, bool vert, bool reversed, bool continuous)
		{
			fixed (uint* pcolors = &colors)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					RenderColorBarNative((uint*)pcolors, size, (ImDrawList*)pdrawList, bounds, vert ? (byte)1 : (byte)0, reversed ? (byte)1 : (byte)0, continuous ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double NiceNumNative(double x, byte round)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, byte, double>)funcTable[651])(x, round);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, byte, double>)funcTable[651])(x, round);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double NiceNum(double x, bool round)
		{
			double ret = NiceNumNative(x, round ? (byte)1 : (byte)0);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int OrderOfMagnitudeNative(double val)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, int>)funcTable[652])(val);
			#else
			return (int)((delegate* unmanaged[Cdecl]<double, int>)funcTable[652])(val);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int OrderOfMagnitude(double val)
		{
			int ret = OrderOfMagnitudeNative(val);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int OrderToPrecisionNative(int order)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[653])(order);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[653])(order);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int OrderToPrecision(int order)
		{
			int ret = OrderToPrecisionNative(order);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int PrecisionNative(double val)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, int>)funcTable[654])(val);
			#else
			return (int)((delegate* unmanaged[Cdecl]<double, int>)funcTable[654])(val);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int Precision(double val)
		{
			int ret = PrecisionNative(val);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double RoundToNative(double val, int prec)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, int, double>)funcTable[655])(val, prec);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, int, double>)funcTable[655])(val, prec);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double RoundTo(double val, int prec)
		{
			double ret = RoundToNative(val, prec);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void IntersectionNative(Vector2* pOut, Vector2 a1, Vector2 a2, Vector2 b1, Vector2 b2)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, Vector2, Vector2, Vector2, Vector2, void>)funcTable[656])(pOut, a1, a2, b1, b2);
			#else
			((delegate* unmanaged[Cdecl]<nint, Vector2, Vector2, Vector2, Vector2, void>)funcTable[656])((nint)pOut, a1, a2, b1, b2);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 Intersection(Vector2 a1, Vector2 a2, Vector2 b1, Vector2 b2)
		{
			Vector2 ret;
			IntersectionNative(&ret, a1, a2, b1, b2);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Intersection(Vector2* pOut, Vector2 a1, Vector2 a2, Vector2 b1, Vector2 b2)
		{
			IntersectionNative(pOut, a1, a2, b1, b2);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Intersection(ref Vector2 pOut, Vector2 a1, Vector2 a2, Vector2 b1, Vector2 b2)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				IntersectionNative((Vector2*)ppOut, a1, a2, b1, b2);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FillRangeNative(ImVector<float>* buffer, int n, float vmin, float vmax)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImVector<float>*, int, float, float, void>)funcTable[657])(buffer, n, vmin, vmax);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, float, float, void>)funcTable[657])((nint)buffer, n, vmin, vmax);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FillRange(ImVector<float>* buffer, int n, float vmin, float vmax)
		{
			FillRangeNative(buffer, n, vmin, vmax);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FillRange(ref ImVector<float> buffer, int n, float vmin, float vmax)
		{
			fixed (ImVector<float>* pbuffer = &buffer)
			{
				FillRangeNative((ImVector<float>*)pbuffer, n, vmin, vmax);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FillRangeNative(ImVector<double>* buffer, int n, double vmin, double vmax)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImVector<double>*, int, double, double, void>)funcTable[658])(buffer, n, vmin, vmax);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, double, double, void>)funcTable[658])((nint)buffer, n, vmin, vmax);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FillRange(ImVector<double>* buffer, int n, double vmin, double vmax)
		{
			FillRangeNative(buffer, n, vmin, vmax);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FillRange(ref ImVector<double> buffer, int n, double vmin, double vmax)
		{
			fixed (ImVector<double>* pbuffer = &buffer)
			{
				FillRangeNative((ImVector<double>*)pbuffer, n, vmin, vmax);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FillRangeNative(ImVector<sbyte>* buffer, int n, byte vmin, byte vmax)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImVector<sbyte>*, int, byte, byte, void>)funcTable[659])(buffer, n, vmin, vmax);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, byte, byte, void>)funcTable[659])((nint)buffer, n, vmin, vmax);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FillRange(ImVector<sbyte>* buffer, int n, byte vmin, byte vmax)
		{
			FillRangeNative(buffer, n, vmin, vmax);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FillRange(ref ImVector<sbyte> buffer, int n, byte vmin, byte vmax)
		{
			fixed (ImVector<sbyte>* pbuffer = &buffer)
			{
				FillRangeNative((ImVector<sbyte>*)pbuffer, n, vmin, vmax);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FillRangeNative(ImVector<byte>* buffer, int n, byte vmin, byte vmax)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImVector<byte>*, int, byte, byte, void>)funcTable[660])(buffer, n, vmin, vmax);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, byte, byte, void>)funcTable[660])((nint)buffer, n, vmin, vmax);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FillRange(ImVector<byte>* buffer, int n, byte vmin, byte vmax)
		{
			FillRangeNative(buffer, n, vmin, vmax);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FillRange(ref ImVector<byte> buffer, int n, byte vmin, byte vmax)
		{
			fixed (ImVector<byte>* pbuffer = &buffer)
			{
				FillRangeNative((ImVector<byte>*)pbuffer, n, vmin, vmax);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FillRangeNative(ImVector<short>* buffer, int n, short vmin, short vmax)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImVector<short>*, int, short, short, void>)funcTable[661])(buffer, n, vmin, vmax);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, short, short, void>)funcTable[661])((nint)buffer, n, vmin, vmax);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FillRange(ImVector<short>* buffer, int n, short vmin, short vmax)
		{
			FillRangeNative(buffer, n, vmin, vmax);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FillRange(ref ImVector<short> buffer, int n, short vmin, short vmax)
		{
			fixed (ImVector<short>* pbuffer = &buffer)
			{
				FillRangeNative((ImVector<short>*)pbuffer, n, vmin, vmax);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FillRangeNative(ImVector<ushort>* buffer, int n, ushort vmin, ushort vmax)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImVector<ushort>*, int, ushort, ushort, void>)funcTable[662])(buffer, n, vmin, vmax);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, ushort, ushort, void>)funcTable[662])((nint)buffer, n, vmin, vmax);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FillRange(ImVector<ushort>* buffer, int n, ushort vmin, ushort vmax)
		{
			FillRangeNative(buffer, n, vmin, vmax);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FillRange(ref ImVector<ushort> buffer, int n, ushort vmin, ushort vmax)
		{
			fixed (ImVector<ushort>* pbuffer = &buffer)
			{
				FillRangeNative((ImVector<ushort>*)pbuffer, n, vmin, vmax);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FillRangeNative(ImVector<int>* buffer, int n, int vmin, int vmax)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImVector<int>*, int, int, int, void>)funcTable[663])(buffer, n, vmin, vmax);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, int, int, void>)funcTable[663])((nint)buffer, n, vmin, vmax);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FillRange(ImVector<int>* buffer, int n, int vmin, int vmax)
		{
			FillRangeNative(buffer, n, vmin, vmax);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FillRange(ref ImVector<int> buffer, int n, int vmin, int vmax)
		{
			fixed (ImVector<int>* pbuffer = &buffer)
			{
				FillRangeNative((ImVector<int>*)pbuffer, n, vmin, vmax);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FillRangeNative(ImVector<uint>* buffer, int n, uint vmin, uint vmax)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImVector<uint>*, int, uint, uint, void>)funcTable[664])(buffer, n, vmin, vmax);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, uint, uint, void>)funcTable[664])((nint)buffer, n, vmin, vmax);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FillRange(ImVector<uint>* buffer, int n, uint vmin, uint vmax)
		{
			FillRangeNative(buffer, n, vmin, vmax);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FillRange(ref ImVector<uint> buffer, int n, uint vmin, uint vmax)
		{
			fixed (ImVector<uint>* pbuffer = &buffer)
			{
				FillRangeNative((ImVector<uint>*)pbuffer, n, vmin, vmax);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FillRangeNative(ImVector<long>* buffer, int n, long vmin, long vmax)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImVector<long>*, int, long, long, void>)funcTable[665])(buffer, n, vmin, vmax);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, long, long, void>)funcTable[665])((nint)buffer, n, vmin, vmax);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FillRange(ImVector<long>* buffer, int n, long vmin, long vmax)
		{
			FillRangeNative(buffer, n, vmin, vmax);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FillRange(ref ImVector<long> buffer, int n, long vmin, long vmax)
		{
			fixed (ImVector<long>* pbuffer = &buffer)
			{
				FillRangeNative((ImVector<long>*)pbuffer, n, vmin, vmax);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FillRangeNative(ImVector<ulong>* buffer, int n, ulong vmin, ulong vmax)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImVector<ulong>*, int, ulong, ulong, void>)funcTable[666])(buffer, n, vmin, vmax);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, ulong, ulong, void>)funcTable[666])((nint)buffer, n, vmin, vmax);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FillRange(ImVector<ulong>* buffer, int n, ulong vmin, ulong vmax)
		{
			FillRangeNative(buffer, n, vmin, vmax);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FillRange(ref ImVector<ulong> buffer, int n, ulong vmin, ulong vmax)
		{
			fixed (ImVector<ulong>* pbuffer = &buffer)
			{
				FillRangeNative((ImVector<ulong>*)pbuffer, n, vmin, vmax);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CalculateBinsNative(float* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float*, int, ImPlotBin, ImPlotRange, int*, double*, void>)funcTable[667])(values, count, meth, range, binsOut, widthOut);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, ImPlotBin, ImPlotRange, nint, nint, void>)funcTable[667])((nint)values, count, meth, range, (nint)binsOut, (nint)widthOut);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(float* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut)
		{
			CalculateBinsNative(values, count, meth, range, binsOut, widthOut);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(ref float values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut)
		{
			fixed (float* pvalues = &values)
			{
				CalculateBinsNative((float*)pvalues, count, meth, range, binsOut, widthOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(float* values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, double* widthOut)
		{
			fixed (int* pbinsOut = &binsOut)
			{
				CalculateBinsNative(values, count, meth, range, (int*)pbinsOut, widthOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(ref float values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, double* widthOut)
		{
			fixed (float* pvalues = &values)
			{
				fixed (int* pbinsOut = &binsOut)
				{
					CalculateBinsNative((float*)pvalues, count, meth, range, (int*)pbinsOut, widthOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(float* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, ref double widthOut)
		{
			fixed (double* pwidthOut = &widthOut)
			{
				CalculateBinsNative(values, count, meth, range, binsOut, (double*)pwidthOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(ref float values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, ref double widthOut)
		{
			fixed (float* pvalues = &values)
			{
				fixed (double* pwidthOut = &widthOut)
				{
					CalculateBinsNative((float*)pvalues, count, meth, range, binsOut, (double*)pwidthOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(float* values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, ref double widthOut)
		{
			fixed (int* pbinsOut = &binsOut)
			{
				fixed (double* pwidthOut = &widthOut)
				{
					CalculateBinsNative(values, count, meth, range, (int*)pbinsOut, (double*)pwidthOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(ref float values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, ref double widthOut)
		{
			fixed (float* pvalues = &values)
			{
				fixed (int* pbinsOut = &binsOut)
				{
					fixed (double* pwidthOut = &widthOut)
					{
						CalculateBinsNative((float*)pvalues, count, meth, range, (int*)pbinsOut, (double*)pwidthOut);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CalculateBinsNative(double* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double*, int, ImPlotBin, ImPlotRange, int*, double*, void>)funcTable[668])(values, count, meth, range, binsOut, widthOut);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, ImPlotBin, ImPlotRange, nint, nint, void>)funcTable[668])((nint)values, count, meth, range, (nint)binsOut, (nint)widthOut);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(double* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut)
		{
			CalculateBinsNative(values, count, meth, range, binsOut, widthOut);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(ref double values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut)
		{
			fixed (double* pvalues = &values)
			{
				CalculateBinsNative((double*)pvalues, count, meth, range, binsOut, widthOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(double* values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, double* widthOut)
		{
			fixed (int* pbinsOut = &binsOut)
			{
				CalculateBinsNative(values, count, meth, range, (int*)pbinsOut, widthOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(ref double values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, double* widthOut)
		{
			fixed (double* pvalues = &values)
			{
				fixed (int* pbinsOut = &binsOut)
				{
					CalculateBinsNative((double*)pvalues, count, meth, range, (int*)pbinsOut, widthOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(double* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, ref double widthOut)
		{
			fixed (double* pwidthOut = &widthOut)
			{
				CalculateBinsNative(values, count, meth, range, binsOut, (double*)pwidthOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(ref double values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, ref double widthOut)
		{
			fixed (double* pvalues = &values)
			{
				fixed (double* pwidthOut = &widthOut)
				{
					CalculateBinsNative((double*)pvalues, count, meth, range, binsOut, (double*)pwidthOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(double* values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, ref double widthOut)
		{
			fixed (int* pbinsOut = &binsOut)
			{
				fixed (double* pwidthOut = &widthOut)
				{
					CalculateBinsNative(values, count, meth, range, (int*)pbinsOut, (double*)pwidthOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(ref double values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, ref double widthOut)
		{
			fixed (double* pvalues = &values)
			{
				fixed (int* pbinsOut = &binsOut)
				{
					fixed (double* pwidthOut = &widthOut)
					{
						CalculateBinsNative((double*)pvalues, count, meth, range, (int*)pbinsOut, (double*)pwidthOut);
					}
				}
			}
		}
	}
}
