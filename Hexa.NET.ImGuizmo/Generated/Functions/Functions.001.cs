// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;
using Hexa.NET.ImGui;

namespace Hexa.NET.ImGuizmo
{
	public unsafe partial class ImGuizmo
	{

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Manipulate(float* view, ref float projection, ImGuizmoOperation operation, ImGuizmoMode mode, ref float matrix, ref float deltaMatrix, ref float snap, float* localBounds, ref float boundsSnap)
		{
			fixed (float* pprojection = &projection)
			{
				fixed (float* pmatrix = &matrix)
				{
					fixed (float* pdeltaMatrix = &deltaMatrix)
					{
						fixed (float* psnap = &snap)
						{
							fixed (float* pboundsSnap = &boundsSnap)
							{
								byte ret = ManipulateNative(view, (float*)pprojection, operation, mode, (float*)pmatrix, (float*)pdeltaMatrix, (float*)psnap, localBounds, (float*)pboundsSnap);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Manipulate(ref float view, ref float projection, ImGuizmoOperation operation, ImGuizmoMode mode, ref float matrix, ref float deltaMatrix, ref float snap, float* localBounds, ref float boundsSnap)
		{
			fixed (float* pview = &view)
			{
				fixed (float* pprojection = &projection)
				{
					fixed (float* pmatrix = &matrix)
					{
						fixed (float* pdeltaMatrix = &deltaMatrix)
						{
							fixed (float* psnap = &snap)
							{
								fixed (float* pboundsSnap = &boundsSnap)
								{
									byte ret = ManipulateNative((float*)pview, (float*)pprojection, operation, mode, (float*)pmatrix, (float*)pdeltaMatrix, (float*)psnap, localBounds, (float*)pboundsSnap);
									return ret != 0;
								}
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Manipulate(float* view, float* projection, ImGuizmoOperation operation, ImGuizmoMode mode, float* matrix, float* deltaMatrix, float* snap, ref float localBounds, ref float boundsSnap)
		{
			fixed (float* plocalBounds = &localBounds)
			{
				fixed (float* pboundsSnap = &boundsSnap)
				{
					byte ret = ManipulateNative(view, projection, operation, mode, matrix, deltaMatrix, snap, (float*)plocalBounds, (float*)pboundsSnap);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Manipulate(ref float view, float* projection, ImGuizmoOperation operation, ImGuizmoMode mode, float* matrix, float* deltaMatrix, float* snap, ref float localBounds, ref float boundsSnap)
		{
			fixed (float* pview = &view)
			{
				fixed (float* plocalBounds = &localBounds)
				{
					fixed (float* pboundsSnap = &boundsSnap)
					{
						byte ret = ManipulateNative((float*)pview, projection, operation, mode, matrix, deltaMatrix, snap, (float*)plocalBounds, (float*)pboundsSnap);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Manipulate(float* view, ref float projection, ImGuizmoOperation operation, ImGuizmoMode mode, float* matrix, float* deltaMatrix, float* snap, ref float localBounds, ref float boundsSnap)
		{
			fixed (float* pprojection = &projection)
			{
				fixed (float* plocalBounds = &localBounds)
				{
					fixed (float* pboundsSnap = &boundsSnap)
					{
						byte ret = ManipulateNative(view, (float*)pprojection, operation, mode, matrix, deltaMatrix, snap, (float*)plocalBounds, (float*)pboundsSnap);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Manipulate(ref float view, ref float projection, ImGuizmoOperation operation, ImGuizmoMode mode, float* matrix, float* deltaMatrix, float* snap, ref float localBounds, ref float boundsSnap)
		{
			fixed (float* pview = &view)
			{
				fixed (float* pprojection = &projection)
				{
					fixed (float* plocalBounds = &localBounds)
					{
						fixed (float* pboundsSnap = &boundsSnap)
						{
							byte ret = ManipulateNative((float*)pview, (float*)pprojection, operation, mode, matrix, deltaMatrix, snap, (float*)plocalBounds, (float*)pboundsSnap);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Manipulate(float* view, float* projection, ImGuizmoOperation operation, ImGuizmoMode mode, ref float matrix, float* deltaMatrix, float* snap, ref float localBounds, ref float boundsSnap)
		{
			fixed (float* pmatrix = &matrix)
			{
				fixed (float* plocalBounds = &localBounds)
				{
					fixed (float* pboundsSnap = &boundsSnap)
					{
						byte ret = ManipulateNative(view, projection, operation, mode, (float*)pmatrix, deltaMatrix, snap, (float*)plocalBounds, (float*)pboundsSnap);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Manipulate(ref float view, float* projection, ImGuizmoOperation operation, ImGuizmoMode mode, ref float matrix, float* deltaMatrix, float* snap, ref float localBounds, ref float boundsSnap)
		{
			fixed (float* pview = &view)
			{
				fixed (float* pmatrix = &matrix)
				{
					fixed (float* plocalBounds = &localBounds)
					{
						fixed (float* pboundsSnap = &boundsSnap)
						{
							byte ret = ManipulateNative((float*)pview, projection, operation, mode, (float*)pmatrix, deltaMatrix, snap, (float*)plocalBounds, (float*)pboundsSnap);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Manipulate(float* view, ref float projection, ImGuizmoOperation operation, ImGuizmoMode mode, ref float matrix, float* deltaMatrix, float* snap, ref float localBounds, ref float boundsSnap)
		{
			fixed (float* pprojection = &projection)
			{
				fixed (float* pmatrix = &matrix)
				{
					fixed (float* plocalBounds = &localBounds)
					{
						fixed (float* pboundsSnap = &boundsSnap)
						{
							byte ret = ManipulateNative(view, (float*)pprojection, operation, mode, (float*)pmatrix, deltaMatrix, snap, (float*)plocalBounds, (float*)pboundsSnap);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Manipulate(ref float view, ref float projection, ImGuizmoOperation operation, ImGuizmoMode mode, ref float matrix, float* deltaMatrix, float* snap, ref float localBounds, ref float boundsSnap)
		{
			fixed (float* pview = &view)
			{
				fixed (float* pprojection = &projection)
				{
					fixed (float* pmatrix = &matrix)
					{
						fixed (float* plocalBounds = &localBounds)
						{
							fixed (float* pboundsSnap = &boundsSnap)
							{
								byte ret = ManipulateNative((float*)pview, (float*)pprojection, operation, mode, (float*)pmatrix, deltaMatrix, snap, (float*)plocalBounds, (float*)pboundsSnap);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Manipulate(float* view, float* projection, ImGuizmoOperation operation, ImGuizmoMode mode, float* matrix, ref float deltaMatrix, float* snap, ref float localBounds, ref float boundsSnap)
		{
			fixed (float* pdeltaMatrix = &deltaMatrix)
			{
				fixed (float* plocalBounds = &localBounds)
				{
					fixed (float* pboundsSnap = &boundsSnap)
					{
						byte ret = ManipulateNative(view, projection, operation, mode, matrix, (float*)pdeltaMatrix, snap, (float*)plocalBounds, (float*)pboundsSnap);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Manipulate(ref float view, float* projection, ImGuizmoOperation operation, ImGuizmoMode mode, float* matrix, ref float deltaMatrix, float* snap, ref float localBounds, ref float boundsSnap)
		{
			fixed (float* pview = &view)
			{
				fixed (float* pdeltaMatrix = &deltaMatrix)
				{
					fixed (float* plocalBounds = &localBounds)
					{
						fixed (float* pboundsSnap = &boundsSnap)
						{
							byte ret = ManipulateNative((float*)pview, projection, operation, mode, matrix, (float*)pdeltaMatrix, snap, (float*)plocalBounds, (float*)pboundsSnap);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Manipulate(float* view, ref float projection, ImGuizmoOperation operation, ImGuizmoMode mode, float* matrix, ref float deltaMatrix, float* snap, ref float localBounds, ref float boundsSnap)
		{
			fixed (float* pprojection = &projection)
			{
				fixed (float* pdeltaMatrix = &deltaMatrix)
				{
					fixed (float* plocalBounds = &localBounds)
					{
						fixed (float* pboundsSnap = &boundsSnap)
						{
							byte ret = ManipulateNative(view, (float*)pprojection, operation, mode, matrix, (float*)pdeltaMatrix, snap, (float*)plocalBounds, (float*)pboundsSnap);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Manipulate(ref float view, ref float projection, ImGuizmoOperation operation, ImGuizmoMode mode, float* matrix, ref float deltaMatrix, float* snap, ref float localBounds, ref float boundsSnap)
		{
			fixed (float* pview = &view)
			{
				fixed (float* pprojection = &projection)
				{
					fixed (float* pdeltaMatrix = &deltaMatrix)
					{
						fixed (float* plocalBounds = &localBounds)
						{
							fixed (float* pboundsSnap = &boundsSnap)
							{
								byte ret = ManipulateNative((float*)pview, (float*)pprojection, operation, mode, matrix, (float*)pdeltaMatrix, snap, (float*)plocalBounds, (float*)pboundsSnap);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Manipulate(float* view, float* projection, ImGuizmoOperation operation, ImGuizmoMode mode, ref float matrix, ref float deltaMatrix, float* snap, ref float localBounds, ref float boundsSnap)
		{
			fixed (float* pmatrix = &matrix)
			{
				fixed (float* pdeltaMatrix = &deltaMatrix)
				{
					fixed (float* plocalBounds = &localBounds)
					{
						fixed (float* pboundsSnap = &boundsSnap)
						{
							byte ret = ManipulateNative(view, projection, operation, mode, (float*)pmatrix, (float*)pdeltaMatrix, snap, (float*)plocalBounds, (float*)pboundsSnap);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Manipulate(ref float view, float* projection, ImGuizmoOperation operation, ImGuizmoMode mode, ref float matrix, ref float deltaMatrix, float* snap, ref float localBounds, ref float boundsSnap)
		{
			fixed (float* pview = &view)
			{
				fixed (float* pmatrix = &matrix)
				{
					fixed (float* pdeltaMatrix = &deltaMatrix)
					{
						fixed (float* plocalBounds = &localBounds)
						{
							fixed (float* pboundsSnap = &boundsSnap)
							{
								byte ret = ManipulateNative((float*)pview, projection, operation, mode, (float*)pmatrix, (float*)pdeltaMatrix, snap, (float*)plocalBounds, (float*)pboundsSnap);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Manipulate(float* view, ref float projection, ImGuizmoOperation operation, ImGuizmoMode mode, ref float matrix, ref float deltaMatrix, float* snap, ref float localBounds, ref float boundsSnap)
		{
			fixed (float* pprojection = &projection)
			{
				fixed (float* pmatrix = &matrix)
				{
					fixed (float* pdeltaMatrix = &deltaMatrix)
					{
						fixed (float* plocalBounds = &localBounds)
						{
							fixed (float* pboundsSnap = &boundsSnap)
							{
								byte ret = ManipulateNative(view, (float*)pprojection, operation, mode, (float*)pmatrix, (float*)pdeltaMatrix, snap, (float*)plocalBounds, (float*)pboundsSnap);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Manipulate(ref float view, ref float projection, ImGuizmoOperation operation, ImGuizmoMode mode, ref float matrix, ref float deltaMatrix, float* snap, ref float localBounds, ref float boundsSnap)
		{
			fixed (float* pview = &view)
			{
				fixed (float* pprojection = &projection)
				{
					fixed (float* pmatrix = &matrix)
					{
						fixed (float* pdeltaMatrix = &deltaMatrix)
						{
							fixed (float* plocalBounds = &localBounds)
							{
								fixed (float* pboundsSnap = &boundsSnap)
								{
									byte ret = ManipulateNative((float*)pview, (float*)pprojection, operation, mode, (float*)pmatrix, (float*)pdeltaMatrix, snap, (float*)plocalBounds, (float*)pboundsSnap);
									return ret != 0;
								}
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Manipulate(float* view, float* projection, ImGuizmoOperation operation, ImGuizmoMode mode, float* matrix, float* deltaMatrix, ref float snap, ref float localBounds, ref float boundsSnap)
		{
			fixed (float* psnap = &snap)
			{
				fixed (float* plocalBounds = &localBounds)
				{
					fixed (float* pboundsSnap = &boundsSnap)
					{
						byte ret = ManipulateNative(view, projection, operation, mode, matrix, deltaMatrix, (float*)psnap, (float*)plocalBounds, (float*)pboundsSnap);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Manipulate(ref float view, float* projection, ImGuizmoOperation operation, ImGuizmoMode mode, float* matrix, float* deltaMatrix, ref float snap, ref float localBounds, ref float boundsSnap)
		{
			fixed (float* pview = &view)
			{
				fixed (float* psnap = &snap)
				{
					fixed (float* plocalBounds = &localBounds)
					{
						fixed (float* pboundsSnap = &boundsSnap)
						{
							byte ret = ManipulateNative((float*)pview, projection, operation, mode, matrix, deltaMatrix, (float*)psnap, (float*)plocalBounds, (float*)pboundsSnap);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Manipulate(float* view, ref float projection, ImGuizmoOperation operation, ImGuizmoMode mode, float* matrix, float* deltaMatrix, ref float snap, ref float localBounds, ref float boundsSnap)
		{
			fixed (float* pprojection = &projection)
			{
				fixed (float* psnap = &snap)
				{
					fixed (float* plocalBounds = &localBounds)
					{
						fixed (float* pboundsSnap = &boundsSnap)
						{
							byte ret = ManipulateNative(view, (float*)pprojection, operation, mode, matrix, deltaMatrix, (float*)psnap, (float*)plocalBounds, (float*)pboundsSnap);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Manipulate(ref float view, ref float projection, ImGuizmoOperation operation, ImGuizmoMode mode, float* matrix, float* deltaMatrix, ref float snap, ref float localBounds, ref float boundsSnap)
		{
			fixed (float* pview = &view)
			{
				fixed (float* pprojection = &projection)
				{
					fixed (float* psnap = &snap)
					{
						fixed (float* plocalBounds = &localBounds)
						{
							fixed (float* pboundsSnap = &boundsSnap)
							{
								byte ret = ManipulateNative((float*)pview, (float*)pprojection, operation, mode, matrix, deltaMatrix, (float*)psnap, (float*)plocalBounds, (float*)pboundsSnap);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Manipulate(float* view, float* projection, ImGuizmoOperation operation, ImGuizmoMode mode, ref float matrix, float* deltaMatrix, ref float snap, ref float localBounds, ref float boundsSnap)
		{
			fixed (float* pmatrix = &matrix)
			{
				fixed (float* psnap = &snap)
				{
					fixed (float* plocalBounds = &localBounds)
					{
						fixed (float* pboundsSnap = &boundsSnap)
						{
							byte ret = ManipulateNative(view, projection, operation, mode, (float*)pmatrix, deltaMatrix, (float*)psnap, (float*)plocalBounds, (float*)pboundsSnap);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Manipulate(ref float view, float* projection, ImGuizmoOperation operation, ImGuizmoMode mode, ref float matrix, float* deltaMatrix, ref float snap, ref float localBounds, ref float boundsSnap)
		{
			fixed (float* pview = &view)
			{
				fixed (float* pmatrix = &matrix)
				{
					fixed (float* psnap = &snap)
					{
						fixed (float* plocalBounds = &localBounds)
						{
							fixed (float* pboundsSnap = &boundsSnap)
							{
								byte ret = ManipulateNative((float*)pview, projection, operation, mode, (float*)pmatrix, deltaMatrix, (float*)psnap, (float*)plocalBounds, (float*)pboundsSnap);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Manipulate(float* view, ref float projection, ImGuizmoOperation operation, ImGuizmoMode mode, ref float matrix, float* deltaMatrix, ref float snap, ref float localBounds, ref float boundsSnap)
		{
			fixed (float* pprojection = &projection)
			{
				fixed (float* pmatrix = &matrix)
				{
					fixed (float* psnap = &snap)
					{
						fixed (float* plocalBounds = &localBounds)
						{
							fixed (float* pboundsSnap = &boundsSnap)
							{
								byte ret = ManipulateNative(view, (float*)pprojection, operation, mode, (float*)pmatrix, deltaMatrix, (float*)psnap, (float*)plocalBounds, (float*)pboundsSnap);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Manipulate(ref float view, ref float projection, ImGuizmoOperation operation, ImGuizmoMode mode, ref float matrix, float* deltaMatrix, ref float snap, ref float localBounds, ref float boundsSnap)
		{
			fixed (float* pview = &view)
			{
				fixed (float* pprojection = &projection)
				{
					fixed (float* pmatrix = &matrix)
					{
						fixed (float* psnap = &snap)
						{
							fixed (float* plocalBounds = &localBounds)
							{
								fixed (float* pboundsSnap = &boundsSnap)
								{
									byte ret = ManipulateNative((float*)pview, (float*)pprojection, operation, mode, (float*)pmatrix, deltaMatrix, (float*)psnap, (float*)plocalBounds, (float*)pboundsSnap);
									return ret != 0;
								}
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Manipulate(float* view, float* projection, ImGuizmoOperation operation, ImGuizmoMode mode, float* matrix, ref float deltaMatrix, ref float snap, ref float localBounds, ref float boundsSnap)
		{
			fixed (float* pdeltaMatrix = &deltaMatrix)
			{
				fixed (float* psnap = &snap)
				{
					fixed (float* plocalBounds = &localBounds)
					{
						fixed (float* pboundsSnap = &boundsSnap)
						{
							byte ret = ManipulateNative(view, projection, operation, mode, matrix, (float*)pdeltaMatrix, (float*)psnap, (float*)plocalBounds, (float*)pboundsSnap);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Manipulate(ref float view, float* projection, ImGuizmoOperation operation, ImGuizmoMode mode, float* matrix, ref float deltaMatrix, ref float snap, ref float localBounds, ref float boundsSnap)
		{
			fixed (float* pview = &view)
			{
				fixed (float* pdeltaMatrix = &deltaMatrix)
				{
					fixed (float* psnap = &snap)
					{
						fixed (float* plocalBounds = &localBounds)
						{
							fixed (float* pboundsSnap = &boundsSnap)
							{
								byte ret = ManipulateNative((float*)pview, projection, operation, mode, matrix, (float*)pdeltaMatrix, (float*)psnap, (float*)plocalBounds, (float*)pboundsSnap);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Manipulate(float* view, ref float projection, ImGuizmoOperation operation, ImGuizmoMode mode, float* matrix, ref float deltaMatrix, ref float snap, ref float localBounds, ref float boundsSnap)
		{
			fixed (float* pprojection = &projection)
			{
				fixed (float* pdeltaMatrix = &deltaMatrix)
				{
					fixed (float* psnap = &snap)
					{
						fixed (float* plocalBounds = &localBounds)
						{
							fixed (float* pboundsSnap = &boundsSnap)
							{
								byte ret = ManipulateNative(view, (float*)pprojection, operation, mode, matrix, (float*)pdeltaMatrix, (float*)psnap, (float*)plocalBounds, (float*)pboundsSnap);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Manipulate(ref float view, ref float projection, ImGuizmoOperation operation, ImGuizmoMode mode, float* matrix, ref float deltaMatrix, ref float snap, ref float localBounds, ref float boundsSnap)
		{
			fixed (float* pview = &view)
			{
				fixed (float* pprojection = &projection)
				{
					fixed (float* pdeltaMatrix = &deltaMatrix)
					{
						fixed (float* psnap = &snap)
						{
							fixed (float* plocalBounds = &localBounds)
							{
								fixed (float* pboundsSnap = &boundsSnap)
								{
									byte ret = ManipulateNative((float*)pview, (float*)pprojection, operation, mode, matrix, (float*)pdeltaMatrix, (float*)psnap, (float*)plocalBounds, (float*)pboundsSnap);
									return ret != 0;
								}
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Manipulate(float* view, float* projection, ImGuizmoOperation operation, ImGuizmoMode mode, ref float matrix, ref float deltaMatrix, ref float snap, ref float localBounds, ref float boundsSnap)
		{
			fixed (float* pmatrix = &matrix)
			{
				fixed (float* pdeltaMatrix = &deltaMatrix)
				{
					fixed (float* psnap = &snap)
					{
						fixed (float* plocalBounds = &localBounds)
						{
							fixed (float* pboundsSnap = &boundsSnap)
							{
								byte ret = ManipulateNative(view, projection, operation, mode, (float*)pmatrix, (float*)pdeltaMatrix, (float*)psnap, (float*)plocalBounds, (float*)pboundsSnap);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Manipulate(ref float view, float* projection, ImGuizmoOperation operation, ImGuizmoMode mode, ref float matrix, ref float deltaMatrix, ref float snap, ref float localBounds, ref float boundsSnap)
		{
			fixed (float* pview = &view)
			{
				fixed (float* pmatrix = &matrix)
				{
					fixed (float* pdeltaMatrix = &deltaMatrix)
					{
						fixed (float* psnap = &snap)
						{
							fixed (float* plocalBounds = &localBounds)
							{
								fixed (float* pboundsSnap = &boundsSnap)
								{
									byte ret = ManipulateNative((float*)pview, projection, operation, mode, (float*)pmatrix, (float*)pdeltaMatrix, (float*)psnap, (float*)plocalBounds, (float*)pboundsSnap);
									return ret != 0;
								}
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Manipulate(float* view, ref float projection, ImGuizmoOperation operation, ImGuizmoMode mode, ref float matrix, ref float deltaMatrix, ref float snap, ref float localBounds, ref float boundsSnap)
		{
			fixed (float* pprojection = &projection)
			{
				fixed (float* pmatrix = &matrix)
				{
					fixed (float* pdeltaMatrix = &deltaMatrix)
					{
						fixed (float* psnap = &snap)
						{
							fixed (float* plocalBounds = &localBounds)
							{
								fixed (float* pboundsSnap = &boundsSnap)
								{
									byte ret = ManipulateNative(view, (float*)pprojection, operation, mode, (float*)pmatrix, (float*)pdeltaMatrix, (float*)psnap, (float*)plocalBounds, (float*)pboundsSnap);
									return ret != 0;
								}
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Manipulate(ref float view, ref float projection, ImGuizmoOperation operation, ImGuizmoMode mode, ref float matrix, ref float deltaMatrix, ref float snap, ref float localBounds, ref float boundsSnap)
		{
			fixed (float* pview = &view)
			{
				fixed (float* pprojection = &projection)
				{
					fixed (float* pmatrix = &matrix)
					{
						fixed (float* pdeltaMatrix = &deltaMatrix)
						{
							fixed (float* psnap = &snap)
							{
								fixed (float* plocalBounds = &localBounds)
								{
									fixed (float* pboundsSnap = &boundsSnap)
									{
										byte ret = ManipulateNative((float*)pview, (float*)pprojection, operation, mode, (float*)pmatrix, (float*)pdeltaMatrix, (float*)psnap, (float*)plocalBounds, (float*)pboundsSnap);
										return ret != 0;
									}
								}
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ViewManipulateNative(float* view, float length, Vector2 position, Vector2 size, uint backgroundColor)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float*, float, Vector2, Vector2, uint, void>)funcTable[16])(view, length, position, size, backgroundColor);
			#else
			((delegate* unmanaged[Cdecl]<nint, float, Vector2, Vector2, uint, void>)funcTable[16])((nint)view, length, position, size, backgroundColor);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ViewManipulate(float* view, float length, Vector2 position, Vector2 size, uint backgroundColor)
		{
			ViewManipulateNative(view, length, position, size, backgroundColor);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ViewManipulate(ref Matrix4x4 view, float length, Vector2 position, Vector2 size, uint backgroundColor)
		{
			fixed (Matrix4x4* pview = &view)
			{
				ViewManipulateNative((float*)pview, length, position, size, backgroundColor);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ViewManipulate(ref float view, float length, Vector2 position, Vector2 size, uint backgroundColor)
		{
			fixed (float* pview = &view)
			{
				ViewManipulateNative((float*)pview, length, position, size, backgroundColor);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ViewManipulateNative(float* view, float* projection, ImGuizmoOperation operation, ImGuizmoMode mode, float* matrix, float length, Vector2 position, Vector2 size, uint backgroundColor)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float*, float*, ImGuizmoOperation, ImGuizmoMode, float*, float, Vector2, Vector2, uint, void>)funcTable[17])(view, projection, operation, mode, matrix, length, position, size, backgroundColor);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, ImGuizmoOperation, ImGuizmoMode, nint, float, Vector2, Vector2, uint, void>)funcTable[17])((nint)view, (nint)projection, operation, mode, (nint)matrix, length, position, size, backgroundColor);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ViewManipulate(float* view, float* projection, ImGuizmoOperation operation, ImGuizmoMode mode, float* matrix, float length, Vector2 position, Vector2 size, uint backgroundColor)
		{
			ViewManipulateNative(view, projection, operation, mode, matrix, length, position, size, backgroundColor);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ViewManipulate(ref Matrix4x4 view, ref Matrix4x4 projection, ImGuizmoOperation operation, ImGuizmoMode mode, ref Matrix4x4 matrix, float length, Vector2 position, Vector2 size, uint backgroundColor)
		{
			fixed (Matrix4x4* pview = &view)
			{
				fixed (Matrix4x4* pprojection = &projection)
				{
					fixed (Matrix4x4* pmatrix = &matrix)
					{
						ViewManipulateNative((float*)pview, (float*)pprojection, operation, mode, (float*)pmatrix, length, position, size, backgroundColor);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ViewManipulate(ref float view, float* projection, ImGuizmoOperation operation, ImGuizmoMode mode, float* matrix, float length, Vector2 position, Vector2 size, uint backgroundColor)
		{
			fixed (float* pview = &view)
			{
				ViewManipulateNative((float*)pview, projection, operation, mode, matrix, length, position, size, backgroundColor);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ViewManipulate(float* view, ref float projection, ImGuizmoOperation operation, ImGuizmoMode mode, float* matrix, float length, Vector2 position, Vector2 size, uint backgroundColor)
		{
			fixed (float* pprojection = &projection)
			{
				ViewManipulateNative(view, (float*)pprojection, operation, mode, matrix, length, position, size, backgroundColor);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ViewManipulate(ref float view, ref float projection, ImGuizmoOperation operation, ImGuizmoMode mode, float* matrix, float length, Vector2 position, Vector2 size, uint backgroundColor)
		{
			fixed (float* pview = &view)
			{
				fixed (float* pprojection = &projection)
				{
					ViewManipulateNative((float*)pview, (float*)pprojection, operation, mode, matrix, length, position, size, backgroundColor);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ViewManipulate(float* view, float* projection, ImGuizmoOperation operation, ImGuizmoMode mode, ref float matrix, float length, Vector2 position, Vector2 size, uint backgroundColor)
		{
			fixed (float* pmatrix = &matrix)
			{
				ViewManipulateNative(view, projection, operation, mode, (float*)pmatrix, length, position, size, backgroundColor);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ViewManipulate(ref float view, float* projection, ImGuizmoOperation operation, ImGuizmoMode mode, ref float matrix, float length, Vector2 position, Vector2 size, uint backgroundColor)
		{
			fixed (float* pview = &view)
			{
				fixed (float* pmatrix = &matrix)
				{
					ViewManipulateNative((float*)pview, projection, operation, mode, (float*)pmatrix, length, position, size, backgroundColor);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ViewManipulate(float* view, ref float projection, ImGuizmoOperation operation, ImGuizmoMode mode, ref float matrix, float length, Vector2 position, Vector2 size, uint backgroundColor)
		{
			fixed (float* pprojection = &projection)
			{
				fixed (float* pmatrix = &matrix)
				{
					ViewManipulateNative(view, (float*)pprojection, operation, mode, (float*)pmatrix, length, position, size, backgroundColor);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ViewManipulate(ref float view, ref float projection, ImGuizmoOperation operation, ImGuizmoMode mode, ref float matrix, float length, Vector2 position, Vector2 size, uint backgroundColor)
		{
			fixed (float* pview = &view)
			{
				fixed (float* pprojection = &projection)
				{
					fixed (float* pmatrix = &matrix)
					{
						ViewManipulateNative((float*)pview, (float*)pprojection, operation, mode, (float*)pmatrix, length, position, size, backgroundColor);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetAlternativeWindowNative(ImGuiWindow* window)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiWindow*, void>)funcTable[18])(window);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[18])((nint)window);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetAlternativeWindow(ImGuiWindowPtr window)
		{
			SetAlternativeWindowNative(window);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetAlternativeWindow(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetAlternativeWindowNative((ImGuiWindow*)pwindow);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetIDNative(int id)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[19])(id);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[19])(id);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetID(int id)
		{
			SetIDNative(id);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PushIDNative(byte* strId)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, void>)funcTable[20])(strId);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[20])((nint)strId);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushID(byte* strId)
		{
			PushIDNative(strId);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushID(ref byte strId)
		{
			fixed (byte* pstrId = &strId)
			{
				PushIDNative((byte*)pstrId);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushID(ReadOnlySpan<byte> strId)
		{
			fixed (byte* pstrId = strId)
			{
				PushIDNative((byte*)pstrId);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushID(string strId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PushIDNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PushIDNative(byte* strIdBegin, byte* strIdEnd)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, byte*, void>)funcTable[21])(strIdBegin, strIdEnd);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[21])((nint)strIdBegin, (nint)strIdEnd);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushID(byte* strIdBegin, byte* strIdEnd)
		{
			PushIDNative(strIdBegin, strIdEnd);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushID(ref byte strIdBegin, byte* strIdEnd)
		{
			fixed (byte* pstrIdBegin = &strIdBegin)
			{
				PushIDNative((byte*)pstrIdBegin, strIdEnd);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushID(ReadOnlySpan<byte> strIdBegin, byte* strIdEnd)
		{
			fixed (byte* pstrIdBegin = strIdBegin)
			{
				PushIDNative((byte*)pstrIdBegin, strIdEnd);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushID(string strIdBegin, byte* strIdEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strIdBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strIdBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strIdBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PushIDNative(pStr0, strIdEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushID(byte* strIdBegin, ref byte strIdEnd)
		{
			fixed (byte* pstrIdEnd = &strIdEnd)
			{
				PushIDNative(strIdBegin, (byte*)pstrIdEnd);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushID(byte* strIdBegin, ReadOnlySpan<byte> strIdEnd)
		{
			fixed (byte* pstrIdEnd = strIdEnd)
			{
				PushIDNative(strIdBegin, (byte*)pstrIdEnd);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushID(byte* strIdBegin, string strIdEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strIdEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strIdEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strIdEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PushIDNative(strIdBegin, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushID(ref byte strIdBegin, ref byte strIdEnd)
		{
			fixed (byte* pstrIdBegin = &strIdBegin)
			{
				fixed (byte* pstrIdEnd = &strIdEnd)
				{
					PushIDNative((byte*)pstrIdBegin, (byte*)pstrIdEnd);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushID(ReadOnlySpan<byte> strIdBegin, ReadOnlySpan<byte> strIdEnd)
		{
			fixed (byte* pstrIdBegin = strIdBegin)
			{
				fixed (byte* pstrIdEnd = strIdEnd)
				{
					PushIDNative((byte*)pstrIdBegin, (byte*)pstrIdEnd);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushID(string strIdBegin, string strIdEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strIdBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strIdBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strIdBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (strIdEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(strIdEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(strIdEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			PushIDNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushID(ref byte strIdBegin, ReadOnlySpan<byte> strIdEnd)
		{
			fixed (byte* pstrIdBegin = &strIdBegin)
			{
				fixed (byte* pstrIdEnd = strIdEnd)
				{
					PushIDNative((byte*)pstrIdBegin, (byte*)pstrIdEnd);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushID(ref byte strIdBegin, string strIdEnd)
		{
			fixed (byte* pstrIdBegin = &strIdBegin)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (strIdEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(strIdEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(strIdEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PushIDNative((byte*)pstrIdBegin, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushID(ReadOnlySpan<byte> strIdBegin, ref byte strIdEnd)
		{
			fixed (byte* pstrIdBegin = strIdBegin)
			{
				fixed (byte* pstrIdEnd = &strIdEnd)
				{
					PushIDNative((byte*)pstrIdBegin, (byte*)pstrIdEnd);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushID(ReadOnlySpan<byte> strIdBegin, string strIdEnd)
		{
			fixed (byte* pstrIdBegin = strIdBegin)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (strIdEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(strIdEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(strIdEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PushIDNative((byte*)pstrIdBegin, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushID(string strIdBegin, ref byte strIdEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strIdBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strIdBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strIdBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pstrIdEnd = &strIdEnd)
			{
				PushIDNative(pStr0, (byte*)pstrIdEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushID(string strIdBegin, ReadOnlySpan<byte> strIdEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strIdBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strIdBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strIdBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pstrIdEnd = strIdEnd)
			{
				PushIDNative(pStr0, (byte*)pstrIdEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PushIDNative(void* ptrId)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void*, void>)funcTable[22])(ptrId);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[22])((nint)ptrId);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushID(void* ptrId)
		{
			PushIDNative(ptrId);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PushIDNative(int intId)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[23])(intId);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[23])(intId);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushID(int intId)
		{
			PushIDNative(intId);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PopIDNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[24])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[24])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PopID()
		{
			PopIDNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetIDNative(byte* strId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, uint>)funcTable[25])(strId);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)funcTable[25])((nint)strId);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(byte* strId)
		{
			uint ret = GetIDNative(strId);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ref byte strId)
		{
			fixed (byte* pstrId = &strId)
			{
				uint ret = GetIDNative((byte*)pstrId);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ReadOnlySpan<byte> strId)
		{
			fixed (byte* pstrId = strId)
			{
				uint ret = GetIDNative((byte*)pstrId);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(string strId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			uint ret = GetIDNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetIDNative(byte* strIdBegin, byte* strIdEnd)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, uint>)funcTable[26])(strIdBegin, strIdEnd);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, uint>)funcTable[26])((nint)strIdBegin, (nint)strIdEnd);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(byte* strIdBegin, byte* strIdEnd)
		{
			uint ret = GetIDNative(strIdBegin, strIdEnd);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ref byte strIdBegin, byte* strIdEnd)
		{
			fixed (byte* pstrIdBegin = &strIdBegin)
			{
				uint ret = GetIDNative((byte*)pstrIdBegin, strIdEnd);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ReadOnlySpan<byte> strIdBegin, byte* strIdEnd)
		{
			fixed (byte* pstrIdBegin = strIdBegin)
			{
				uint ret = GetIDNative((byte*)pstrIdBegin, strIdEnd);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(string strIdBegin, byte* strIdEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strIdBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strIdBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strIdBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			uint ret = GetIDNative(pStr0, strIdEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(byte* strIdBegin, ref byte strIdEnd)
		{
			fixed (byte* pstrIdEnd = &strIdEnd)
			{
				uint ret = GetIDNative(strIdBegin, (byte*)pstrIdEnd);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(byte* strIdBegin, ReadOnlySpan<byte> strIdEnd)
		{
			fixed (byte* pstrIdEnd = strIdEnd)
			{
				uint ret = GetIDNative(strIdBegin, (byte*)pstrIdEnd);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(byte* strIdBegin, string strIdEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strIdEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strIdEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strIdEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			uint ret = GetIDNative(strIdBegin, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ref byte strIdBegin, ref byte strIdEnd)
		{
			fixed (byte* pstrIdBegin = &strIdBegin)
			{
				fixed (byte* pstrIdEnd = &strIdEnd)
				{
					uint ret = GetIDNative((byte*)pstrIdBegin, (byte*)pstrIdEnd);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ReadOnlySpan<byte> strIdBegin, ReadOnlySpan<byte> strIdEnd)
		{
			fixed (byte* pstrIdBegin = strIdBegin)
			{
				fixed (byte* pstrIdEnd = strIdEnd)
				{
					uint ret = GetIDNative((byte*)pstrIdBegin, (byte*)pstrIdEnd);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(string strIdBegin, string strIdEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strIdBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strIdBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strIdBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (strIdEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(strIdEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(strIdEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			uint ret = GetIDNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ref byte strIdBegin, ReadOnlySpan<byte> strIdEnd)
		{
			fixed (byte* pstrIdBegin = &strIdBegin)
			{
				fixed (byte* pstrIdEnd = strIdEnd)
				{
					uint ret = GetIDNative((byte*)pstrIdBegin, (byte*)pstrIdEnd);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ref byte strIdBegin, string strIdEnd)
		{
			fixed (byte* pstrIdBegin = &strIdBegin)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (strIdEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(strIdEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(strIdEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				uint ret = GetIDNative((byte*)pstrIdBegin, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ReadOnlySpan<byte> strIdBegin, ref byte strIdEnd)
		{
			fixed (byte* pstrIdBegin = strIdBegin)
			{
				fixed (byte* pstrIdEnd = &strIdEnd)
				{
					uint ret = GetIDNative((byte*)pstrIdBegin, (byte*)pstrIdEnd);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ReadOnlySpan<byte> strIdBegin, string strIdEnd)
		{
			fixed (byte* pstrIdBegin = strIdBegin)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (strIdEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(strIdEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(strIdEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				uint ret = GetIDNative((byte*)pstrIdBegin, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(string strIdBegin, ref byte strIdEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strIdBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strIdBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strIdBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pstrIdEnd = &strIdEnd)
			{
				uint ret = GetIDNative(pStr0, (byte*)pstrIdEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(string strIdBegin, ReadOnlySpan<byte> strIdEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strIdBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strIdBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strIdBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pstrIdEnd = strIdEnd)
			{
				uint ret = GetIDNative(pStr0, (byte*)pstrIdEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetIDNative(void* ptrId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, uint>)funcTable[27])(ptrId);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)funcTable[27])((nint)ptrId);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(void* ptrId)
		{
			uint ret = GetIDNative(ptrId);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsOverNative(ImGuizmoOperation op)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuizmoOperation, byte>)funcTable[28])(op);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImGuizmoOperation, byte>)funcTable[28])(op);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsOver(ImGuizmoOperation op)
		{
			byte ret = IsOverNative(op);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetGizmoSizeClipSpaceNative(float value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[29])(value);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[29])(value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetGizmoSizeClipSpace(float value)
		{
			SetGizmoSizeClipSpaceNative(value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void AllowAxisFlipNative(byte value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte, void>)funcTable[30])(value);
			#else
			((delegate* unmanaged[Cdecl]<byte, void>)funcTable[30])(value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AllowAxisFlip(bool value)
		{
			AllowAxisFlipNative(value ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetAxisLimitNative(float value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[31])(value);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[31])(value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetAxisLimit(float value)
		{
			SetAxisLimitNative(value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetAxisMaskNative(byte x, byte y, byte z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte, byte, byte, void>)funcTable[32])(x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<byte, byte, byte, void>)funcTable[32])(x, y, z);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetAxisMask(bool x, bool y, bool z)
		{
			SetAxisMaskNative(x ? (byte)1 : (byte)0, y ? (byte)1 : (byte)0, z ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetPlaneLimitNative(float value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[33])(value);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[33])(value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetPlaneLimit(float value)
		{
			SetPlaneLimitNative(value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsOverNative(float* position, float pixelRadius)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float*, float, byte>)funcTable[34])(position, pixelRadius);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, float, byte>)funcTable[34])((nint)position, pixelRadius);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsOver(float* position, float pixelRadius)
		{
			byte ret = IsOverNative(position, pixelRadius);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsOver(ref float position, float pixelRadius)
		{
			fixed (float* pposition = &position)
			{
				byte ret = IsOverNative((float*)pposition, pixelRadius);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Style* StyleNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Style*>)funcTable[35])();
			#else
			return (Style*)((delegate* unmanaged[Cdecl]<nint>)funcTable[35])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static StylePtr Style()
		{
			StylePtr ret = StyleNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(Style* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Style*, void>)funcTable[36])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[36])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(StylePtr self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref Style self)
		{
			fixed (Style* pself = &self)
			{
				DestroyNative((Style*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Style* GetStyleNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Style*>)funcTable[37])();
			#else
			return (Style*)((delegate* unmanaged[Cdecl]<nint>)funcTable[37])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static StylePtr GetStyle()
		{
			StylePtr ret = GetStyleNative();
			return ret;
		}

	}
}
