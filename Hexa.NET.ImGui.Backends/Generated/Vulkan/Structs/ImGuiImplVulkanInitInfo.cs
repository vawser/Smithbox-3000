// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;
using Hexa.NET.ImGui;

namespace Hexa.NET.ImGui.Backends.Vulkan
{
	/// <summary>
	/// Initialization data, for ImGui_ImplVulkan_Init()<br/>
	/// - VkDescriptorPool should be created with VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT,<br/>
	/// and must contain a pool size large enough to hold an ImGui VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER descriptor.<br/>
	/// - When using dynamic rendering, set UseDynamicRendering=true and fill PipelineRenderingCreateInfo structure.<br/>
	/// [Please zero-clear before use!]<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiImplVulkanInitInfo
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public VkInstance Instance;

		/// <summary>
		/// To be documented.
		/// </summary>
		public VkPhysicalDevice PhysicalDevice;

		/// <summary>
		/// To be documented.
		/// </summary>
		public VkDevice Device;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint QueueFamily;

		/// <summary>
		/// To be documented.
		/// </summary>
		public VkQueue Queue;

		/// <summary>
		/// See requirements in note above<br/>
		/// </summary>
		public VkDescriptorPool DescriptorPool;

		/// <summary>
		/// Ignored if using dynamic rendering<br/>
		/// </summary>
		public VkRenderPass RenderPass;

		/// <summary>
		/// >= 2<br/>
		/// </summary>
		public uint MinImageCount;

		/// <summary>
		/// >= MinImageCount<br/>
		/// </summary>
		public uint ImageCount;

		/// <summary>
		/// 0 defaults to VK_SAMPLE_COUNT_1_BIT<br/>
		/// </summary>
		public uint MSAASamples;

		/// <summary>
		/// (Optional)<br/>
		/// </summary>
		public VkPipelineCache PipelineCache;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint Subpass;

		/// <summary>
		/// (Optional) Dynamic Rendering<br/>
		/// Need to explicitly enable VK_KHR_dynamic_rendering extension to use this, even for Vulkan 1.3.<br/>
		/// </summary>
		public byte UseDynamicRendering;

		/// <summary>
		/// To be documented.
		/// </summary>
		public VkPipelineRenderingCreateInfo PipelineRenderingCreateInfo;

		/// <summary>
		/// (Optional) Allocation, Debugging<br/>
		/// </summary>
		public unsafe VkAllocationCallbacks* Allocator;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* CheckVkResultFn;

		/// <summary>
		/// Minimum allocation size. Set to 1024*1024 to satisfy zealous best practices validation layer and waste a little memory.<br/>
		/// </summary>
		public ulong MinAllocationSize;


		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiImplVulkanInitInfo(VkInstance instance = default, VkPhysicalDevice physicalDevice = default, VkDevice device = default, uint queueFamily = default, VkQueue queue = default, VkDescriptorPool descriptorPool = default, VkRenderPass renderPass = default, uint minImageCount = default, uint imageCount = default, uint msaaSamples = default, VkPipelineCache pipelineCache = default, uint subpass = default, bool useDynamicRendering = default, VkPipelineRenderingCreateInfo pipelineRenderingCreateInfo = default, VkAllocationCallbacks* allocator = default, delegate*<int, void> checkVkResultFn = default, ulong minAllocationSize = default)
		{
			Instance = instance;
			PhysicalDevice = physicalDevice;
			Device = device;
			QueueFamily = queueFamily;
			Queue = queue;
			DescriptorPool = descriptorPool;
			RenderPass = renderPass;
			MinImageCount = minImageCount;
			ImageCount = imageCount;
			MSAASamples = msaaSamples;
			PipelineCache = pipelineCache;
			Subpass = subpass;
			UseDynamicRendering = useDynamicRendering ? (byte)1 : (byte)0;
			PipelineRenderingCreateInfo = pipelineRenderingCreateInfo;
			Allocator = allocator;
			CheckVkResultFn = (void*)checkVkResultFn;
			MinAllocationSize = minAllocationSize;
		}


	}

	/// <summary>
	/// Initialization data, for ImGui_ImplVulkan_Init()<br/>
	/// - VkDescriptorPool should be created with VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT,<br/>
	/// and must contain a pool size large enough to hold an ImGui VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER descriptor.<br/>
	/// - When using dynamic rendering, set UseDynamicRendering=true and fill PipelineRenderingCreateInfo structure.<br/>
	/// [Please zero-clear before use!]<br/>
	/// </summary>
	#if NET5_0_OR_GREATER
	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	#endif
	public unsafe struct ImGuiImplVulkanInitInfoPtr : IEquatable<ImGuiImplVulkanInitInfoPtr>
	{
		public ImGuiImplVulkanInitInfoPtr(ImGuiImplVulkanInitInfo* handle) { Handle = handle; }

		public ImGuiImplVulkanInitInfo* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiImplVulkanInitInfoPtr Null => new ImGuiImplVulkanInitInfoPtr(null);

		public ImGuiImplVulkanInitInfo this[int index] { get => Handle[index]; set => Handle[index] = value; }

		public static implicit operator ImGuiImplVulkanInitInfoPtr(ImGuiImplVulkanInitInfo* handle) => new ImGuiImplVulkanInitInfoPtr(handle);

		public static implicit operator ImGuiImplVulkanInitInfo*(ImGuiImplVulkanInitInfoPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiImplVulkanInitInfoPtr left, ImGuiImplVulkanInitInfoPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiImplVulkanInitInfoPtr left, ImGuiImplVulkanInitInfoPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiImplVulkanInitInfoPtr left, ImGuiImplVulkanInitInfo* right) => left.Handle == right;

		public static bool operator !=(ImGuiImplVulkanInitInfoPtr left, ImGuiImplVulkanInitInfo* right) => left.Handle != right;

		public bool Equals(ImGuiImplVulkanInitInfoPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiImplVulkanInitInfoPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		#if NET5_0_OR_GREATER
		private string DebuggerDisplay => string.Format("ImGuiImplVulkanInitInfoPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		#endif
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref VkInstance Instance => ref Unsafe.AsRef<VkInstance>(&Handle->Instance);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref VkPhysicalDevice PhysicalDevice => ref Unsafe.AsRef<VkPhysicalDevice>(&Handle->PhysicalDevice);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref VkDevice Device => ref Unsafe.AsRef<VkDevice>(&Handle->Device);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref uint QueueFamily => ref Unsafe.AsRef<uint>(&Handle->QueueFamily);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref VkQueue Queue => ref Unsafe.AsRef<VkQueue>(&Handle->Queue);
		/// <summary>
		/// See requirements in note above<br/>
		/// </summary>
		public ref VkDescriptorPool DescriptorPool => ref Unsafe.AsRef<VkDescriptorPool>(&Handle->DescriptorPool);
		/// <summary>
		/// Ignored if using dynamic rendering<br/>
		/// </summary>
		public ref VkRenderPass RenderPass => ref Unsafe.AsRef<VkRenderPass>(&Handle->RenderPass);
		/// <summary>
		/// >= 2<br/>
		/// </summary>
		public ref uint MinImageCount => ref Unsafe.AsRef<uint>(&Handle->MinImageCount);
		/// <summary>
		/// >= MinImageCount<br/>
		/// </summary>
		public ref uint ImageCount => ref Unsafe.AsRef<uint>(&Handle->ImageCount);
		/// <summary>
		/// 0 defaults to VK_SAMPLE_COUNT_1_BIT<br/>
		/// </summary>
		public ref uint MSAASamples => ref Unsafe.AsRef<uint>(&Handle->MSAASamples);
		/// <summary>
		/// (Optional)<br/>
		/// </summary>
		public ref VkPipelineCache PipelineCache => ref Unsafe.AsRef<VkPipelineCache>(&Handle->PipelineCache);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref uint Subpass => ref Unsafe.AsRef<uint>(&Handle->Subpass);
		/// <summary>
		/// (Optional) Dynamic Rendering<br/>
		/// Need to explicitly enable VK_KHR_dynamic_rendering extension to use this, even for Vulkan 1.3.<br/>
		/// </summary>
		public ref bool UseDynamicRendering => ref Unsafe.AsRef<bool>(&Handle->UseDynamicRendering);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref VkPipelineRenderingCreateInfo PipelineRenderingCreateInfo => ref Unsafe.AsRef<VkPipelineRenderingCreateInfo>(&Handle->PipelineRenderingCreateInfo);
		/// <summary>
		/// (Optional) Allocation, Debugging<br/>
		/// </summary>
		public ref VkAllocationCallbacks Allocator => ref Unsafe.AsRef<VkAllocationCallbacks>(&Handle->Allocator);
		/// <summary>
		/// To be documented.
		/// </summary>
		public void* CheckVkResultFn { get => Handle->CheckVkResultFn; set => Handle->CheckVkResultFn = value; }
		/// <summary>
		/// Minimum allocation size. Set to 1024*1024 to satisfy zealous best practices validation layer and waste a little memory.<br/>
		/// </summary>
		public ref ulong MinAllocationSize => ref Unsafe.AsRef<ulong>(&Handle->MinAllocationSize);
	}

}
