// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;
using Hexa.NET.ImGui;

namespace Hexa.NET.ImGui.Backends.Vulkan
{
	/// <summary>
	/// Helper structure to hold the data needed by one rendering context into one OS window<br/>
	/// (Used by example's main.cpp. Used by multi-viewport features. Probably NOT used by your own engine/app.)<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiImplVulkanHWindow
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Width;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Height;

		/// <summary>
		/// To be documented.
		/// </summary>
		public VkSwapchainKHR Swapchain;

		/// <summary>
		/// To be documented.
		/// </summary>
		public VkSurfaceKHR Surface;

		/// <summary>
		/// To be documented.
		/// </summary>
		public VkSurfaceFormatKHR SurfaceFormat;

		/// <summary>
		/// To be documented.
		/// </summary>
		public VkPresentModeKHR PresentMode;

		/// <summary>
		/// To be documented.
		/// </summary>
		public VkRenderPass RenderPass;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte UseDynamicRendering;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte ClearEnable;

		/// <summary>
		/// To be documented.
		/// </summary>
		public VkClearValue ClearValue;

		/// <summary>
		/// Current frame being rendered to (0 <br/>
		/// <<br/>
		/// = FrameIndex <br/>
		/// <<br/>
		/// FrameInFlightCount)<br/>
		/// </summary>
		public uint FrameIndex;

		/// <summary>
		/// Number of simultaneous in-flight frames (returned by vkGetSwapchainImagesKHR, usually derived from min_image_count)<br/>
		/// </summary>
		public uint ImageCount;

		/// <summary>
		/// Number of simultaneous in-flight frames + 1, to be able to use it in vkAcquireNextImageKHR<br/>
		/// </summary>
		public uint SemaphoreCount;

		/// <summary>
		/// Current set of swapchain wait semaphores we're using (needs to be distinct from per frame data)<br/>
		/// </summary>
		public uint SemaphoreIndex;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiImplVulkanHFrame* Frames;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiImplVulkanHFrameSemaphores* FrameSemaphores;


		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiImplVulkanHWindow(int width = default, int height = default, VkSwapchainKHR swapchain = default, VkSurfaceKHR surface = default, VkSurfaceFormatKHR surfaceFormat = default, VkPresentModeKHR presentMode = default, VkRenderPass renderPass = default, bool useDynamicRendering = default, bool clearEnable = default, VkClearValue clearValue = default, uint frameIndex = default, uint imageCount = default, uint semaphoreCount = default, uint semaphoreIndex = default, ImGuiImplVulkanHFramePtr frames = default, ImGuiImplVulkanHFrameSemaphores* frameSemaphores = default)
		{
			Width = width;
			Height = height;
			Swapchain = swapchain;
			Surface = surface;
			SurfaceFormat = surfaceFormat;
			PresentMode = presentMode;
			RenderPass = renderPass;
			UseDynamicRendering = useDynamicRendering ? (byte)1 : (byte)0;
			ClearEnable = clearEnable ? (byte)1 : (byte)0;
			ClearValue = clearValue;
			FrameIndex = frameIndex;
			ImageCount = imageCount;
			SemaphoreCount = semaphoreCount;
			SemaphoreIndex = semaphoreIndex;
			Frames = frames;
			FrameSemaphores = frameSemaphores;
		}


	}

	/// <summary>
	/// Helper structure to hold the data needed by one rendering context into one OS window<br/>
	/// (Used by example's main.cpp. Used by multi-viewport features. Probably NOT used by your own engine/app.)<br/>
	/// </summary>
	#if NET5_0_OR_GREATER
	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	#endif
	public unsafe struct ImGuiImplVulkanHWindowPtr : IEquatable<ImGuiImplVulkanHWindowPtr>
	{
		public ImGuiImplVulkanHWindowPtr(ImGuiImplVulkanHWindow* handle) { Handle = handle; }

		public ImGuiImplVulkanHWindow* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiImplVulkanHWindowPtr Null => new ImGuiImplVulkanHWindowPtr(null);

		public ImGuiImplVulkanHWindow this[int index] { get => Handle[index]; set => Handle[index] = value; }

		public static implicit operator ImGuiImplVulkanHWindowPtr(ImGuiImplVulkanHWindow* handle) => new ImGuiImplVulkanHWindowPtr(handle);

		public static implicit operator ImGuiImplVulkanHWindow*(ImGuiImplVulkanHWindowPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiImplVulkanHWindowPtr left, ImGuiImplVulkanHWindowPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiImplVulkanHWindowPtr left, ImGuiImplVulkanHWindowPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiImplVulkanHWindowPtr left, ImGuiImplVulkanHWindow* right) => left.Handle == right;

		public static bool operator !=(ImGuiImplVulkanHWindowPtr left, ImGuiImplVulkanHWindow* right) => left.Handle != right;

		public bool Equals(ImGuiImplVulkanHWindowPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiImplVulkanHWindowPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		#if NET5_0_OR_GREATER
		private string DebuggerDisplay => string.Format("ImGuiImplVulkanHWindowPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		#endif
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref int Width => ref Unsafe.AsRef<int>(&Handle->Width);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref int Height => ref Unsafe.AsRef<int>(&Handle->Height);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref VkSwapchainKHR Swapchain => ref Unsafe.AsRef<VkSwapchainKHR>(&Handle->Swapchain);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref VkSurfaceKHR Surface => ref Unsafe.AsRef<VkSurfaceKHR>(&Handle->Surface);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref VkSurfaceFormatKHR SurfaceFormat => ref Unsafe.AsRef<VkSurfaceFormatKHR>(&Handle->SurfaceFormat);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref VkPresentModeKHR PresentMode => ref Unsafe.AsRef<VkPresentModeKHR>(&Handle->PresentMode);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref VkRenderPass RenderPass => ref Unsafe.AsRef<VkRenderPass>(&Handle->RenderPass);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref bool UseDynamicRendering => ref Unsafe.AsRef<bool>(&Handle->UseDynamicRendering);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref bool ClearEnable => ref Unsafe.AsRef<bool>(&Handle->ClearEnable);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref VkClearValue ClearValue => ref Unsafe.AsRef<VkClearValue>(&Handle->ClearValue);
		/// <summary>
		/// Current frame being rendered to (0 <br/>
		/// <<br/>
		/// = FrameIndex <br/>
		/// <<br/>
		/// FrameInFlightCount)<br/>
		/// </summary>
		public ref uint FrameIndex => ref Unsafe.AsRef<uint>(&Handle->FrameIndex);
		/// <summary>
		/// Number of simultaneous in-flight frames (returned by vkGetSwapchainImagesKHR, usually derived from min_image_count)<br/>
		/// </summary>
		public ref uint ImageCount => ref Unsafe.AsRef<uint>(&Handle->ImageCount);
		/// <summary>
		/// Number of simultaneous in-flight frames + 1, to be able to use it in vkAcquireNextImageKHR<br/>
		/// </summary>
		public ref uint SemaphoreCount => ref Unsafe.AsRef<uint>(&Handle->SemaphoreCount);
		/// <summary>
		/// Current set of swapchain wait semaphores we're using (needs to be distinct from per frame data)<br/>
		/// </summary>
		public ref uint SemaphoreIndex => ref Unsafe.AsRef<uint>(&Handle->SemaphoreIndex);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref ImGuiImplVulkanHFramePtr Frames => ref Unsafe.AsRef<ImGuiImplVulkanHFramePtr>(&Handle->Frames);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref ImGuiImplVulkanHFrameSemaphoresPtr FrameSemaphores => ref Unsafe.AsRef<ImGuiImplVulkanHFrameSemaphoresPtr>(&Handle->FrameSemaphores);
	}

}
