// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;
using Hexa.NET.ImGui;

namespace Hexa.NET.ImGui.Backends.D3D12
{
	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiImplDX12InitInfo
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ID3D12Device* Device;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ID3D12CommandQueue* CommandQueue;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int NumFramesInFlight;

		/// <summary>
		/// RenderTarget format.<br/>
		/// </summary>
		public uint RTVFormat;

		/// <summary>
		/// DepthStencilView format.<br/>
		/// </summary>
		public uint DSVFormat;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* UserData;

		/// <summary>
		/// Allocating SRV descriptors for textures is up to the application, so we provide callbacks.<br/>
		/// (current version of the backend will only allocate one descriptor, future versions will need to allocate more)<br/>
		/// </summary>
		public unsafe ID3D12DescriptorHeap* SrvDescriptorHeap;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* SrvDescriptorAllocFn;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* SrvDescriptorFreeFn;

		/// <summary>
		/// To facilitate transition from single descriptor to allocator callback, you may use those.<br/>
		/// </summary>
		public D3D12CpuDescriptorHandle LegacySingleSrvCpuDescriptor;

		/// <summary>
		/// To be documented.
		/// </summary>
		public D3D12GpuDescriptorHandle LegacySingleSrvGpuDescriptor;


		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiImplDX12InitInfo(ID3D12DevicePtr device = default, ID3D12CommandQueuePtr commandQueue = default, int numFramesInFlight = default, uint rtvFormat = default, uint dsvFormat = default, void* userData = default, ID3D12DescriptorHeapPtr srvDescriptorHeap = default, delegate*<ImGuiImplDX12InitInfo*, D3D12CpuDescriptorHandle*, D3D12GpuDescriptorHandle*, void> srvDescriptorAllocFn = default, delegate*<ImGuiImplDX12InitInfo*, D3D12CpuDescriptorHandle, D3D12GpuDescriptorHandle, void> srvDescriptorFreeFn = default, D3D12CpuDescriptorHandle legacySingleSrvCpuDescriptor = default, D3D12GpuDescriptorHandle legacySingleSrvGpuDescriptor = default)
		{
			Device = device;
			CommandQueue = commandQueue;
			NumFramesInFlight = numFramesInFlight;
			RTVFormat = rtvFormat;
			DSVFormat = dsvFormat;
			UserData = userData;
			SrvDescriptorHeap = srvDescriptorHeap;
			SrvDescriptorAllocFn = (void*)srvDescriptorAllocFn;
			SrvDescriptorFreeFn = (void*)srvDescriptorFreeFn;
			LegacySingleSrvCpuDescriptor = legacySingleSrvCpuDescriptor;
			LegacySingleSrvGpuDescriptor = legacySingleSrvGpuDescriptor;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	#if NET5_0_OR_GREATER
	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	#endif
	public unsafe struct ImGuiImplDX12InitInfoPtr : IEquatable<ImGuiImplDX12InitInfoPtr>
	{
		public ImGuiImplDX12InitInfoPtr(ImGuiImplDX12InitInfo* handle) { Handle = handle; }

		public ImGuiImplDX12InitInfo* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiImplDX12InitInfoPtr Null => new ImGuiImplDX12InitInfoPtr(null);

		public ImGuiImplDX12InitInfo this[int index] { get => Handle[index]; set => Handle[index] = value; }

		public static implicit operator ImGuiImplDX12InitInfoPtr(ImGuiImplDX12InitInfo* handle) => new ImGuiImplDX12InitInfoPtr(handle);

		public static implicit operator ImGuiImplDX12InitInfo*(ImGuiImplDX12InitInfoPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiImplDX12InitInfoPtr left, ImGuiImplDX12InitInfoPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiImplDX12InitInfoPtr left, ImGuiImplDX12InitInfoPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiImplDX12InitInfoPtr left, ImGuiImplDX12InitInfo* right) => left.Handle == right;

		public static bool operator !=(ImGuiImplDX12InitInfoPtr left, ImGuiImplDX12InitInfo* right) => left.Handle != right;

		public bool Equals(ImGuiImplDX12InitInfoPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiImplDX12InitInfoPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		#if NET5_0_OR_GREATER
		private string DebuggerDisplay => string.Format("ImGuiImplDX12InitInfoPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		#endif
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref ID3D12DevicePtr Device => ref Unsafe.AsRef<ID3D12DevicePtr>(&Handle->Device);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref ID3D12CommandQueuePtr CommandQueue => ref Unsafe.AsRef<ID3D12CommandQueuePtr>(&Handle->CommandQueue);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref int NumFramesInFlight => ref Unsafe.AsRef<int>(&Handle->NumFramesInFlight);
		/// <summary>
		/// RenderTarget format.<br/>
		/// </summary>
		public ref uint RTVFormat => ref Unsafe.AsRef<uint>(&Handle->RTVFormat);
		/// <summary>
		/// DepthStencilView format.<br/>
		/// </summary>
		public ref uint DSVFormat => ref Unsafe.AsRef<uint>(&Handle->DSVFormat);
		/// <summary>
		/// To be documented.
		/// </summary>
		public void* UserData { get => Handle->UserData; set => Handle->UserData = value; }
		/// <summary>
		/// Allocating SRV descriptors for textures is up to the application, so we provide callbacks.<br/>
		/// (current version of the backend will only allocate one descriptor, future versions will need to allocate more)<br/>
		/// </summary>
		public ref ID3D12DescriptorHeapPtr SrvDescriptorHeap => ref Unsafe.AsRef<ID3D12DescriptorHeapPtr>(&Handle->SrvDescriptorHeap);
		/// <summary>
		/// To be documented.
		/// </summary>
		public void* SrvDescriptorAllocFn { get => Handle->SrvDescriptorAllocFn; set => Handle->SrvDescriptorAllocFn = value; }
		/// <summary>
		/// To be documented.
		/// </summary>
		public void* SrvDescriptorFreeFn { get => Handle->SrvDescriptorFreeFn; set => Handle->SrvDescriptorFreeFn = value; }
		/// <summary>
		/// To facilitate transition from single descriptor to allocator callback, you may use those.<br/>
		/// </summary>
		public ref D3D12CpuDescriptorHandle LegacySingleSrvCpuDescriptor => ref Unsafe.AsRef<D3D12CpuDescriptorHandle>(&Handle->LegacySingleSrvCpuDescriptor);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref D3D12GpuDescriptorHandle LegacySingleSrvGpuDescriptor => ref Unsafe.AsRef<D3D12GpuDescriptorHandle>(&Handle->LegacySingleSrvGpuDescriptor);
	}

}
